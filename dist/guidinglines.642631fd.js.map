{"version":3,"sources":["guidinglines.js"],"names":["GuidingLines","interval","referenceLine","bbox","lines","generate","position"],"mappings":";;;;;;;;;;;;;IAEqBA;;;AAEjB;AACA;AACA;AACA,0BAA+C;AAAA,QAAnCC,QAAmC,uEAAxB,CAAwB;AAAA,QAArBC,aAAqB;AAAA,QAANC,IAAM;;AAAA;;AAC3C,SAAKF,QAAL,GAAgBA,QAAhB;AACA,SAAKE,IAAL,GAAYA,IAAZ;AACA,SAAKD,aAAL,GAAqBA,aAArB,CAH2C,CAGP;AACpC;;AACA,SAAKE,KAAL,GAAa,EAAb;AACH;;;;+BAEU,CA2BV,EA1BG;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AAGJ;;;;2BACOD,MAAMF,UAAU;AACnB,WAAKE,IAAL,GAAYA,IAAZ;AACA,WAAKF,QAAL,GAAgBA,QAAhB;AACA,WAAKI,QAAL,GAHmB,CAInB;AACH;;;mCAEcC,UAAU,CAKxB,EAJG;AACA;AACA;AACA;AAGJ;;;;iCACa,CACT;AACA;AACH","file":"guidinglines.642631fd.js","sourceRoot":"..","sourcesContent":["\r\n\r\nexport default class GuidingLines {\r\n\r\n    // Interval in meters\r\n    // Bbox : containing bbox of the grid\r\n    // Reference line, strait [pointA, pointB] or curve [pointA, pointB, pointC, pointD]\r\n    constructor(interval = 5, referenceLine, bbox) {\r\n        this.interval = interval;\r\n        this.bbox = bbox;\r\n        this.referenceLine = referenceLine; // TODO see if this could be a \r\n        // this.referenceLineBearing = bearing(firstPoint, lastPoint);\r\n        this.lines = [];\r\n    }\r\n\r\n    generate() {\r\n        // Get Bbox\r\n\r\n        // Enlarge reference line to meet the bbox size\r\n        // TODO, enlarge or cut referenceLine to meet the bbox\r\n        \r\n        // Create all parallels lines and store them\r\n        // var linesRight = []\r\n        // while inside BBOX \r\n        //  var line = turf.lineOffset(line, interval, { units: \"m\" })\r\n        //  TODO, enlarge or cut line to meet the bbox\r\n        //  linesRight.add(line)\r\n\r\n        // var linesLeft = []\r\n        // while inside BBOX (on the other side)\r\n        //  var line = turf.lineOffset(line, -interval, { unites: \"m\"})\r\n        //  TODO, enlarge or cut line to meet the bbox\r\n        //  linesLeft.add(line)\r\n\r\n        //lines.push(linesLeft)\r\n        //lines.push(linesRight)\r\n        \r\n\r\n        // For each assign an index in the property field (this will be used when using getClosestLine for styling)\r\n        // lines.map((line, index) => {\r\n        //   line.property.id = index;\r\n        //})\r\n    }\r\n\r\n    // Change Guiding parameters\r\n    update(bbox, interval) {\r\n        this.bbox = bbox;\r\n        this.interval = interval;\r\n        this.generate();\r\n        // NB: when changing interval / bbox size, the index will change for the lines, so user needs to call getClosestLineAgain\r\n    }\r\n\r\n    getClosestLine(position) {\r\n        // Implement algorithm wrote on paper\r\n        // --> Draw perpendicular line to bearing of reference line\r\n        // --> run a binary search on this.lines to get the closest turf.intersectLine() : https://medium.com/hackernoon/programming-with-js-binary-search-aaf86cef9cb3\r\n        // return line ID + distance to line\r\n    }\r\n\r\n    // Get guiding lines in geojson to display on a map\r\n    getGeojson() {\r\n        // TODO\r\n        //turf.featureCollection(this.lines)\r\n    }\r\n}\r\n\r\n"]}