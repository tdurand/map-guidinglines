{"version":3,"sources":["node_modules/@turf/helpers/index.js","node_modules/@turf/invariant/index.js","node_modules/@turf/meta/index.js","node_modules/@turf/line-segment/index.js","node_modules/rbush/node_modules/quickselect/quickselect.js","node_modules/rbush/index.js","node_modules/@turf/bbox/index.js","node_modules/geojson-rbush/index.js","node_modules/@turf/line-intersect/index.js","node_modules/@turf/line-offset/node_modules/@turf/helpers/main.es.js","node_modules/@turf/line-offset/node_modules/@turf/meta/main.es.js","node_modules/@turf/line-offset/node_modules/@turf/invariant/main.es.js","node_modules/@turf/line-offset/main.es.js","node_modules/@turf/bbox-polygon/index.js","node_modules/@turf/boolean-point-in-polygon/index.js","node_modules/@turf/boolean-point-on-line/index.js","node_modules/@turf/boolean-contains/index.js","node_modules/@turf/bearing/index.js","node_modules/@turf/destination/index.js","node_modules/@turf/distance/index.js","node_modules/@turf/center/index.js","guidinglines.js","app.js","../../../AppData/Roaming/npm/node_modules/parcel-bundler/src/builtins/hmr-runtime.js"],"names":["earthRadius","factors","meters","metres","millimeters","millimetres","centimeters","centimetres","kilometers","kilometres","miles","nauticalmiles","inches","yards","feet","radians","degrees","unitsFactors","areaFactors","acres","feature","geometry","properties","options","isObject","Error","bbox","id","undefined","constructor","Object","validateBBox","validateId","feat","type","coordinates","Array","isArray","geom","point","lineString","polygon","multiPoint","multiLineString","multiPolygon","length","isNumber","points","featureCollection","map","coords","i","ring","j","polygons","lineStrings","features","fc","geometryCollection","geometries","round","num","precision","isNaN","multiplier","Math","pow","radiansToLength","units","factor","lengthToRadians","distance","lengthToDegrees","radiansToDegrees","bearingToAzimuth","bearing","angle","PI","degreesToRadians","convertLength","originalUnit","finalUnit","convertArea","area","startFactor","finalFactor","input","forEach","indexOf","radians2degrees","degrees2radians","distanceToDegrees","distanceToRadians","radiansToDistance","bearingToAngle","convertDistance","coordEach","geojson","callback","excludeWrapCoord","k","l","stopG","geometryMaybeCollection","wrapShrink","coordIndex","isGeometryCollection","isFeatureCollection","isFeature","stop","featureIndex","geomIndex","multiFeatureIndex","geometryIndex","geomType","coordReduce","initialValue","previousValue","currentCoord","propEach","propReduce","currentProperties","featureEach","featureReduce","currentFeature","coordAll","coord","push","geomEach","g","featureProperties","featureBBox","featureId","geomReduce","currentGeometry","flattenEach","coordinate","flattenReduce","segmentEach","feature$$1","segmentIndex","previousCoords","featureIndexCoord","mutliPartIndexCoord","currentSegment","segmentReduce","started","lineEach","lineReduce","currentLine","findSegment","findPoint","getCoord","getCoords","containsNumber","geojsonType","value","name","featureOf","collectionOf","getGeom","getGeomType","getType","ab","segment","start","end","crossProduct","v1","v2","add","sub","scalarMult","s","v","intersectSegments","a","b","p","r","q","cross","qmp","numerator","t","intersection","isParallel","lineOffset","lineOffsetFeature","line","segments","offsetDegrees","finalCoords","currentCoords","index","processSegment","seg2Coords","intersects","point1","point2","offset","L","sqrt","out1x","out2x","out1y","out2y","GuidingLines","interval","referenceLine","lines","computeDerivedParams","bboxGeojson","referenceLineGeojson","referenceLineBearing","referenceLineBearingInverse","bboxDiagonalLength","newBbox","position","halfLength","pointPosition","pointA","pointB","currentLineCoordinates","newLineCoordinates","isLineInBbox","console","log","referenceLineExpanded","expandLine","linesRight","linesLeft","previousLine","lineOffsetted","concat","reverse","perpendicularLine","computePerpendicularLine","found","boundA","boundB","distanceToBoundA","distanceToBoundB","intersectionWithBoundA","intersectionWithBoundB","closestDistance","closest","floor","generate","bboxCenter","newReferenceLine","getClosestLine","mapboxgl","Map","container","style","center","zoom","on","getBounds","toArray","flat","guidingLines","guidingLinesGeojson","closestLine","addSource","addLayer","needResizing","isBiggerThan","updated","updateBbox","getSource","setData","getCenter","window","OVERLAY_ID","OldModule","module","bundle","Module","moduleName","call","hot","data","hotData","_acceptCallbacks","_disposeCallbacks","accept","fn","dispose","checkedAssets","assetsToAccept","parent","isParcelRequire","WebSocket","hostname","location","protocol","ws","onmessage","event","JSON","parse","handled","assets","asset","isNew","didAccept","hmrAcceptCheck","global","parcelRequire","every","generated","js","clear","hmrApply","hmrAcceptRun","reload","close","onclose","removeErrorOverlay","error","message","stack","overlay","createErrorOverlay","document","body","appendChild","getElementById","remove","createElement","stackTrace","innerText","innerHTML","getParents","modules","parents","d","dep","Function","deps","cached","cache","some","cb"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7tBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5mCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC/FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACljBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA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ACA,MAAIG,KAAK,GAAGL,MAAM,CAAC,CAAD,CAAN,GAAYC,MAAM,IAAID,MAAM,CAAC,CAAD,CAAN,GAAYD,MAAM,CAAC,CAAD,CAAtB,CAAN,GAAmCG,CAA3D;AACA,MAAII,KAAK,GAAGP,MAAM,CAAC,CAAD,CAAN,GAAYE,MAAM,IAAIF,MAAM,CAAC,CAAD,CAAN,GAAYC,MAAM,CAAC,CAAD,CAAtB,CAAN,GAAmCE,CAA3D;AACA,MAAIK,KAAK,GAAGP,MAAM,CAAC,CAAD,CAAN,GAAYC,MAAM,IAAIF,MAAM,CAAC,CAAD,CAAN,GAAYC,MAAM,CAAC,CAAD,CAAtB,CAAN,GAAmCE,CAA3D;AACA,SAAO,CAAC,CAACE,KAAD,EAAQE,KAAR,CAAD,EAAiB,CAACD,KAAD,EAAQE,KAAR,CAAjB,CAAP;AACH;;eAEcnB;;;ACrOf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;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","file":"app.c328ef1a.js","sourceRoot":"..","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexports.earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.factors = {\n    centimeters: exports.earthRadius * 100,\n    centimetres: exports.earthRadius * 100,\n    degrees: exports.earthRadius / 111325,\n    feet: exports.earthRadius * 3.28084,\n    inches: exports.earthRadius * 39.370,\n    kilometers: exports.earthRadius / 1000,\n    kilometres: exports.earthRadius / 1000,\n    meters: exports.earthRadius,\n    metres: exports.earthRadius,\n    miles: exports.earthRadius / 1609.344,\n    millimeters: exports.earthRadius * 1000,\n    millimetres: exports.earthRadius * 1000,\n    nauticalmiles: exports.earthRadius / 1852,\n    radians: 1,\n    yards: exports.earthRadius / 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.370,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / exports.earthRadius,\n    yards: 1 / 1.0936,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\nexports.feature = feature;\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nfunction geometry(type, coordinates, options) {\n    if (options === void 0) { options = {}; }\n    switch (type) {\n        case \"Point\": return point(coordinates).geometry;\n        case \"LineString\": return lineString(coordinates).geometry;\n        case \"Polygon\": return polygon(coordinates).geometry;\n        case \"MultiPoint\": return multiPoint(coordinates).geometry;\n        case \"MultiLineString\": return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\": return multiPolygon(coordinates).geometry;\n        default: throw new Error(type + \" is invalid\");\n    }\n}\nexports.geometry = geometry;\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.point = point;\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\nexports.points = points;\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.polygon = polygon;\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\nexports.polygons = polygons;\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.lineString = lineString;\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\nexports.lineStrings = lineStrings;\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\nexports.featureCollection = featureCollection;\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiLineString = multiLineString;\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPoint = multiPoint;\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPolygon = multiPolygon;\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nfunction geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\nexports.geometryCollection = geometryCollection;\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\nexports.round = round;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\nexports.radiansToLength = radiansToLength;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\nexports.lengthToRadians = lengthToRadians;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\nexports.lengthToDegrees = lengthToDegrees;\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\nexports.bearingToAzimuth = bearingToAzimuth;\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\nexports.radiansToDegrees = radiansToDegrees;\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\nexports.degreesToRadians = degreesToRadians;\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\nexports.convertLength = convertLength;\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted distance\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = exports.areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = exports.areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\nexports.convertArea = convertArea;\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num) && !/^\\s*$/.test(num);\n}\nexports.isNumber = isNumber;\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n    return (!!input) && (input.constructor === Object);\n}\nexports.isObject = isObject;\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\nexports.validateBBox = validateBBox;\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\nexports.validateId = validateId;\n// Deprecated methods\nfunction radians2degrees() {\n    throw new Error(\"method has been renamed to `radiansToDegrees`\");\n}\nexports.radians2degrees = radians2degrees;\nfunction degrees2radians() {\n    throw new Error(\"method has been renamed to `degreesToRadians`\");\n}\nexports.degrees2radians = degrees2radians;\nfunction distanceToDegrees() {\n    throw new Error(\"method has been renamed to `lengthToDegrees`\");\n}\nexports.distanceToDegrees = distanceToDegrees;\nfunction distanceToRadians() {\n    throw new Error(\"method has been renamed to `lengthToRadians`\");\n}\nexports.distanceToRadians = distanceToRadians;\nfunction radiansToDistance() {\n    throw new Error(\"method has been renamed to `radiansToLength`\");\n}\nexports.radiansToDistance = radiansToDistance;\nfunction bearingToAngle() {\n    throw new Error(\"method has been renamed to `bearingToAzimuth`\");\n}\nexports.bearingToAngle = bearingToAngle;\nfunction convertDistance() {\n    throw new Error(\"method has been renamed to `convertLength`\");\n}\nexports.convertDistance = convertDistance;\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar helpers_1 = require(\"@turf/helpers\");\r\n/**\r\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\r\n *\r\n * @name getCoord\r\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\r\n * @returns {Array<number>} coordinates\r\n * @example\r\n * var pt = turf.point([10, 10]);\r\n *\r\n * var coord = turf.getCoord(pt);\r\n * //= [10, 10]\r\n */\r\nfunction getCoord(coord) {\r\n    if (!coord) {\r\n        throw new Error(\"coord is required\");\r\n    }\r\n    if (!Array.isArray(coord)) {\r\n        if (coord.type === \"Feature\" && coord.geometry !== null && coord.geometry.type === \"Point\") {\r\n            return coord.geometry.coordinates;\r\n        }\r\n        if (coord.type === \"Point\") {\r\n            return coord.coordinates;\r\n        }\r\n    }\r\n    if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {\r\n        return coord;\r\n    }\r\n    throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\r\n}\r\nexports.getCoord = getCoord;\r\n/**\r\n * Unwrap coordinates from a Feature, Geometry Object or an Array\r\n *\r\n * @name getCoords\r\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\r\n * @returns {Array<any>} coordinates\r\n * @example\r\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\r\n *\r\n * var coords = turf.getCoords(poly);\r\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\r\n */\r\nfunction getCoords(coords) {\r\n    if (Array.isArray(coords)) {\r\n        return coords;\r\n    }\r\n    // Feature\r\n    if (coords.type === \"Feature\") {\r\n        if (coords.geometry !== null) {\r\n            return coords.geometry.coordinates;\r\n        }\r\n    }\r\n    else {\r\n        // Geometry\r\n        if (coords.coordinates) {\r\n            return coords.coordinates;\r\n        }\r\n    }\r\n    throw new Error(\"coords must be GeoJSON Feature, Geometry Object or an Array\");\r\n}\r\nexports.getCoords = getCoords;\r\n/**\r\n * Checks if coordinates contains a number\r\n *\r\n * @name containsNumber\r\n * @param {Array<any>} coordinates GeoJSON Coordinates\r\n * @returns {boolean} true if Array contains a number\r\n */\r\nfunction containsNumber(coordinates) {\r\n    if (coordinates.length > 1 && helpers_1.isNumber(coordinates[0]) && helpers_1.isNumber(coordinates[1])) {\r\n        return true;\r\n    }\r\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\r\n        return containsNumber(coordinates[0]);\r\n    }\r\n    throw new Error(\"coordinates must only contain numbers\");\r\n}\r\nexports.containsNumber = containsNumber;\r\n/**\r\n * Enforce expectations about types of GeoJSON objects for Turf.\r\n *\r\n * @name geojsonType\r\n * @param {GeoJSON} value any GeoJSON object\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} if value is not the expected type.\r\n */\r\nfunction geojsonType(value, type, name) {\r\n    if (!type || !name) {\r\n        throw new Error(\"type and name required\");\r\n    }\r\n    if (!value || value.type !== type) {\r\n        throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + value.type);\r\n    }\r\n}\r\nexports.geojsonType = geojsonType;\r\n/**\r\n * Enforce expectations about types of {@link Feature} inputs for Turf.\r\n * Internally this uses {@link geojsonType} to judge geometry types.\r\n *\r\n * @name featureOf\r\n * @param {Feature} feature a feature with an expected geometry type\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} error if value is not the expected type.\r\n */\r\nfunction featureOf(feature, type, name) {\r\n    if (!feature) {\r\n        throw new Error(\"No feature passed\");\r\n    }\r\n    if (!name) {\r\n        throw new Error(\".featureOf() requires a name\");\r\n    }\r\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\r\n        throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\r\n    }\r\n    if (!feature.geometry || feature.geometry.type !== type) {\r\n        throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type);\r\n    }\r\n}\r\nexports.featureOf = featureOf;\r\n/**\r\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\r\n * Internally this uses {@link geojsonType} to judge geometry types.\r\n *\r\n * @name collectionOf\r\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} if value is not the expected type.\r\n */\r\nfunction collectionOf(featureCollection, type, name) {\r\n    if (!featureCollection) {\r\n        throw new Error(\"No featureCollection passed\");\r\n    }\r\n    if (!name) {\r\n        throw new Error(\".collectionOf() requires a name\");\r\n    }\r\n    if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\r\n        throw new Error(\"Invalid input to \" + name + \", FeatureCollection required\");\r\n    }\r\n    for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {\r\n        var feature = _a[_i];\r\n        if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\r\n            throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\r\n        }\r\n        if (!feature.geometry || feature.geometry.type !== type) {\r\n            throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type);\r\n        }\r\n    }\r\n}\r\nexports.collectionOf = collectionOf;\r\n/**\r\n * Get Geometry from Feature or Geometry Object\r\n *\r\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\r\n * @returns {Geometry|null} GeoJSON Geometry Object\r\n * @throws {Error} if geojson is not a Feature or Geometry Object\r\n * @example\r\n * var point = {\r\n *   \"type\": \"Feature\",\r\n *   \"properties\": {},\r\n *   \"geometry\": {\r\n *     \"type\": \"Point\",\r\n *     \"coordinates\": [110, 40]\r\n *   }\r\n * }\r\n * var geom = turf.getGeom(point)\r\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\r\n */\r\nfunction getGeom(geojson) {\r\n    if (geojson.type === \"Feature\") {\r\n        return geojson.geometry;\r\n    }\r\n    return geojson;\r\n}\r\nexports.getGeom = getGeom;\r\n/**\r\n * Get GeoJSON object's type, Geometry type is prioritize.\r\n *\r\n * @param {GeoJSON} geojson GeoJSON object\r\n * @param {string} [name=\"geojson\"] name of the variable to display in error message\r\n * @returns {string} GeoJSON type\r\n * @example\r\n * var point = {\r\n *   \"type\": \"Feature\",\r\n *   \"properties\": {},\r\n *   \"geometry\": {\r\n *     \"type\": \"Point\",\r\n *     \"coordinates\": [110, 40]\r\n *   }\r\n * }\r\n * var geom = turf.getType(point)\r\n * //=\"Point\"\r\n */\r\nfunction getType(geojson, name) {\r\n    if (geojson.type === \"FeatureCollection\") {\r\n        return \"FeatureCollection\";\r\n    }\r\n    if (geojson.type === \"GeometryCollection\") {\r\n        return \"GeometryCollection\";\r\n    }\r\n    if (geojson.type === \"Feature\" && geojson.geometry !== null) {\r\n        return geojson.geometry.type;\r\n    }\r\n    return geojson.type;\r\n}\r\nexports.getType = getType;\r\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar helpers = require('@turf/helpers');\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n    // Handles null Geometry -- Skips this GeoJSON\n    if (geojson === null) return;\n    var j, k, l, geometry, stopG, coords,\n        geometryMaybeCollection,\n        wrapShrink = 0,\n        coordIndex = 0,\n        isGeometryCollection,\n        type = geojson.type,\n        isFeatureCollection = type === 'FeatureCollection',\n        isFeature = type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n            var multiFeatureIndex = 0;\n            var geometryIndex = 0;\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n\n            // Handles null Geometry -- Skips this geometry\n            if (geometry === null) continue;\n            coords = geometry.coordinates;\n            var geomType = geometry.type;\n\n            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;\n\n            switch (geomType) {\n            case null:\n                break;\n            case 'Point':\n                if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                coordIndex++;\n                multiFeatureIndex++;\n                break;\n            case 'LineString':\n            case 'MultiPoint':\n                for (j = 0; j < coords.length; j++) {\n                    if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                    coordIndex++;\n                    if (geomType === 'MultiPoint') multiFeatureIndex++;\n                }\n                if (geomType === 'LineString') multiFeatureIndex++;\n                break;\n            case 'Polygon':\n            case 'MultiLineString':\n                for (j = 0; j < coords.length; j++) {\n                    for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                        if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                        coordIndex++;\n                    }\n                    if (geomType === 'MultiLineString') multiFeatureIndex++;\n                    if (geomType === 'Polygon') geometryIndex++;\n                }\n                if (geomType === 'Polygon') multiFeatureIndex++;\n                break;\n            case 'MultiPolygon':\n                for (j = 0; j < coords.length; j++) {\n                    geometryIndex = 0;\n                    for (k = 0; k < coords[j].length; k++) {\n                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                            if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                            coordIndex++;\n                        }\n                        geometryIndex++;\n                    }\n                    multiFeatureIndex++;\n                }\n                break;\n            case 'GeometryCollection':\n                for (j = 0; j < geometry.geometries.length; j++)\n                    if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;\n                break;\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n    var previousValue = initialValue;\n    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;\n        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n    }, excludeWrapCoord);\n    return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n    var i;\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        for (i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i].properties, i) === false) break;\n        }\n        break;\n    case 'Feature':\n        callback(geojson.properties, 0);\n        break;\n    }\n}\n\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    propEach(geojson, function (currentProperties, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;\n        else previousValue = callback(previousValue, currentProperties, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n    if (geojson.type === 'Feature') {\n        callback(geojson, 0);\n    } else if (geojson.type === 'FeatureCollection') {\n        for (var i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i], i) === false) break;\n        }\n    }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    featureEach(geojson, function (currentFeature, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n    var coords = [];\n    coordEach(geojson, function (coord) {\n        coords.push(coord);\n    });\n    return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n    var i, j, g, geometry, stopG,\n        geometryMaybeCollection,\n        isGeometryCollection,\n        featureProperties,\n        featureBBox,\n        featureId,\n        featureIndex = 0,\n        isFeatureCollection = geojson.type === 'FeatureCollection',\n        isFeature = geojson.type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        featureProperties = (isFeatureCollection ? geojson.features[i].properties :\n            (isFeature ? geojson.properties : {}));\n        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :\n            (isFeature ? geojson.bbox : undefined));\n        featureId = (isFeatureCollection ? geojson.features[i].id :\n            (isFeature ? geojson.id : undefined));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n            // Handle null Geometry\n            if (geometry === null) {\n                if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                continue;\n            }\n            switch (geometry.type) {\n            case 'Point':\n            case 'LineString':\n            case 'MultiPoint':\n            case 'Polygon':\n            case 'MultiLineString':\n            case 'MultiPolygon': {\n                if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                break;\n            }\n            case 'GeometryCollection': {\n                for (j = 0; j < geometry.geometries.length; j++) {\n                    if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                }\n                break;\n            }\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n        // Only increase `featureIndex` per each feature\n        featureIndex++;\n    }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;\n        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n    geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n        // Callback for single geometry\n        var type = (geometry === null) ? null : geometry.type;\n        switch (type) {\n        case null:\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n            if (callback(helpers.feature(geometry, properties, {bbox: bbox, id: id}), featureIndex, 0) === false) return false;\n            return;\n        }\n\n        var geomType;\n\n        // Callback for multi-geometry\n        switch (type) {\n        case 'MultiPoint':\n            geomType = 'Point';\n            break;\n        case 'MultiLineString':\n            geomType = 'LineString';\n            break;\n        case 'MultiPolygon':\n            geomType = 'Polygon';\n            break;\n        }\n\n        for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n            var coordinate = geometry.coordinates[multiFeatureIndex];\n            var geom = {\n                type: geomType,\n                coordinates: coordinate\n            };\n            if (callback(helpers.feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;\n        }\n    });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {\n        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n        var segmentIndex = 0;\n\n        // Exclude null Geometries\n        if (!feature.geometry) return;\n        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n        var type = feature.geometry.type;\n        if (type === 'Point' || type === 'MultiPoint') return;\n\n        // Generate 2-vertex line segments\n        var previousCoords;\n        var previousFeatureIndex = 0;\n        var previousMultiIndex = 0;\n        var prevGeomIndex = 0;\n        if (coordEach(feature, function (currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {\n            // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n            if (previousCoords === undefined || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {\n                previousCoords = currentCoord;\n                previousFeatureIndex = featureIndex;\n                previousMultiIndex = multiPartIndexCoord;\n                prevGeomIndex = geometryIndex;\n                segmentIndex = 0;\n                return;\n            }\n            var currentSegment = helpers.lineString([previousCoords, currentCoord], feature.properties);\n            if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;\n            segmentIndex++;\n            previousCoords = currentCoord;\n        }) === false) return false;\n    });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentInex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    var started = false;\n    segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n        if (started === false && initialValue === undefined) previousValue = currentSegment;\n        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\n        started = true;\n    });\n    return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n    // validation\n    if (!geojson) throw new Error('geojson is required');\n\n    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n        if (feature.geometry === null) return;\n        var type = feature.geometry.type;\n        var coords = feature.geometry.coordinates;\n        switch (type) {\n        case 'LineString':\n            if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false) return false;\n            break;\n        case 'Polygon':\n            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n                if (callback(helpers.lineString(coords[geometryIndex], feature.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n            }\n            break;\n        }\n    });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;\n        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!helpers.isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var segmentIndex = options.segmentIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find SegmentIndex\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n        if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n        return helpers.lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n        return helpers.lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n        return helpers.lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n        return helpers.lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!helpers.isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var coordIndex = options.coordIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find Coord Index\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n        return helpers.point(coords, properties, options);\n    case 'MultiPoint':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        return helpers.point(coords[multiFeatureIndex], properties, options);\n    case 'LineString':\n        if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n        return helpers.point(coords[coordIndex], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;\n        return helpers.point(coords[geometryIndex][coordIndex], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;\n        return helpers.point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n        return helpers.point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\nexports.coordEach = coordEach;\nexports.coordReduce = coordReduce;\nexports.propEach = propEach;\nexports.propReduce = propReduce;\nexports.featureEach = featureEach;\nexports.featureReduce = featureReduce;\nexports.coordAll = coordAll;\nexports.geomEach = geomEach;\nexports.geomReduce = geomReduce;\nexports.flattenEach = flattenEach;\nexports.flattenReduce = flattenReduce;\nexports.segmentEach = segmentEach;\nexports.segmentReduce = segmentReduce;\nexports.lineEach = lineEach;\nexports.lineReduce = lineReduce;\nexports.findSegment = findSegment;\nexports.findPoint = findPoint;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar helpers_1 = require(\"@turf/helpers\");\nvar invariant_1 = require(\"@turf/invariant\");\nvar meta_1 = require(\"@turf/meta\");\n/**\n * Creates a {@link FeatureCollection} of 2-vertex {@link LineString} segments from a\n * {@link LineString|(Multi)LineString} or {@link Polygon|(Multi)Polygon}.\n *\n * @name lineSegment\n * @param {GeoJSON} geojson GeoJSON Polygon or LineString\n * @returns {FeatureCollection<LineString>} 2-vertex line segments\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n * var segments = turf.lineSegment(polygon);\n *\n * //addToMap\n * var addToMap = [polygon, segments]\n */\nfunction lineSegment(geojson) {\n    if (!geojson) {\n        throw new Error(\"geojson is required\");\n    }\n    var results = [];\n    meta_1.flattenEach(geojson, function (feature) {\n        lineSegmentFeature(feature, results);\n    });\n    return helpers_1.featureCollection(results);\n}\n/**\n * Line Segment\n *\n * @private\n * @param {Feature<LineString|Polygon>} geojson Line or polygon feature\n * @param {Array} results push to results\n * @returns {void}\n */\nfunction lineSegmentFeature(geojson, results) {\n    var coords = [];\n    var geometry = geojson.geometry;\n    if (geometry !== null) {\n        switch (geometry.type) {\n            case \"Polygon\":\n                coords = invariant_1.getCoords(geometry);\n                break;\n            case \"LineString\":\n                coords = [invariant_1.getCoords(geometry)];\n        }\n        coords.forEach(function (coord) {\n            var segments = createSegments(coord, geojson.properties);\n            segments.forEach(function (segment) {\n                segment.id = results.length;\n                results.push(segment);\n            });\n        });\n    }\n}\n/**\n * Create Segments from LineString coordinates\n *\n * @private\n * @param {Array<Array<number>>} coords LineString coordinates\n * @param {*} properties GeoJSON properties\n * @returns {Array<Feature<LineString>>} line segments\n */\nfunction createSegments(coords, properties) {\n    var segments = [];\n    coords.reduce(function (previousCoords, currentCoords) {\n        var segment = helpers_1.lineString([previousCoords, currentCoords], properties);\n        segment.bbox = bbox(previousCoords, currentCoords);\n        segments.push(segment);\n        return currentCoords;\n    });\n    return segments;\n}\n/**\n * Create BBox between two coordinates (faster than @turf/bbox)\n *\n * @private\n * @param {Array<number>} coords1 Point coordinate\n * @param {Array<number>} coords2 Point coordinate\n * @returns {BBox} [west, south, east, north]\n */\nfunction bbox(coords1, coords2) {\n    var x1 = coords1[0];\n    var y1 = coords1[1];\n    var x2 = coords2[0];\n    var y2 = coords2[1];\n    var west = (x1 < x2) ? x1 : x2;\n    var south = (y1 < y2) ? y1 : y2;\n    var east = (x1 > x2) ? x1 : x2;\n    var north = (y1 > y2) ? y1 : y2;\n    return [west, south, east, north];\n}\nexports.default = lineSegment;\n","(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.quickselect = factory());\n}(this, (function () { 'use strict';\n\nfunction quickselect(arr, k, left, right, compare) {\n    quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);\n}\n\nfunction quickselectStep(arr, k, left, right, compare) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            var n = right - left + 1;\n            var m = k - left + 1;\n            var z = Math.log(n);\n            var s = 0.5 * Math.exp(2 * z / 3);\n            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            quickselectStep(arr, k, newLeft, newRight, compare);\n        }\n\n        var t = arr[k];\n        var i = left;\n        var j = right;\n\n        swap(arr, left, k);\n        if (compare(arr[right], t) > 0) swap(arr, left, right);\n\n        while (i < j) {\n            swap(arr, i, j);\n            i++;\n            j--;\n            while (compare(arr[i], t) < 0) i++;\n            while (compare(arr[j], t) > 0) j--;\n        }\n\n        if (compare(arr[left], t) === 0) swap(arr, left, j);\n        else {\n            j++;\n            swap(arr, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\nfunction swap(arr, i, j) {\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n\nreturn quickselect;\n\n})));\n","'use strict';\n\nmodule.exports = rbush;\nmodule.exports.default = rbush;\n\nvar quickselect = require('quickselect');\n\nfunction rbush(maxEntries, format) {\n    if (!(this instanceof rbush)) return new rbush(maxEntries, format);\n\n    // max entries in a node is 9 by default; min node fill is 40% for best performance\n    this._maxEntries = Math.max(4, maxEntries || 9);\n    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n\n    if (format) {\n        this._initFormat(format);\n    }\n\n    this.clear();\n}\n\nrbush.prototype = {\n\n    all: function () {\n        return this._all(this.data, []);\n    },\n\n    search: function (bbox) {\n\n        var node = this.data,\n            result = [],\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return result;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf) result.push(child);\n                    else if (contains(bbox, childBBox)) this._all(child, result);\n                    else nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return result;\n    },\n\n    collides: function (bbox) {\n\n        var node = this.data,\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return false;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf || contains(bbox, childBBox)) return true;\n                    nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return false;\n    },\n\n    load: function (data) {\n        if (!(data && data.length)) return this;\n\n        if (data.length < this._minEntries) {\n            for (var i = 0, len = data.length; i < len; i++) {\n                this.insert(data[i]);\n            }\n            return this;\n        }\n\n        // recursively build the tree with the given data from scratch using OMT algorithm\n        var node = this._build(data.slice(), 0, data.length - 1, 0);\n\n        if (!this.data.children.length) {\n            // save as is if tree is empty\n            this.data = node;\n\n        } else if (this.data.height === node.height) {\n            // split root if trees have the same height\n            this._splitRoot(this.data, node);\n\n        } else {\n            if (this.data.height < node.height) {\n                // swap trees if inserted one is bigger\n                var tmpNode = this.data;\n                this.data = node;\n                node = tmpNode;\n            }\n\n            // insert the small tree into the large tree at appropriate level\n            this._insert(node, this.data.height - node.height - 1, true);\n        }\n\n        return this;\n    },\n\n    insert: function (item) {\n        if (item) this._insert(item, this.data.height - 1);\n        return this;\n    },\n\n    clear: function () {\n        this.data = createNode([]);\n        return this;\n    },\n\n    remove: function (item, equalsFn) {\n        if (!item) return this;\n\n        var node = this.data,\n            bbox = this.toBBox(item),\n            path = [],\n            indexes = [],\n            i, parent, index, goingUp;\n\n        // depth-first iterative tree traversal\n        while (node || path.length) {\n\n            if (!node) { // go up\n                node = path.pop();\n                parent = path[path.length - 1];\n                i = indexes.pop();\n                goingUp = true;\n            }\n\n            if (node.leaf) { // check current node\n                index = findItem(item, node.children, equalsFn);\n\n                if (index !== -1) {\n                    // item found, remove the item and condense tree upwards\n                    node.children.splice(index, 1);\n                    path.push(node);\n                    this._condense(path);\n                    return this;\n                }\n            }\n\n            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down\n                path.push(node);\n                indexes.push(i);\n                i = 0;\n                parent = node;\n                node = node.children[0];\n\n            } else if (parent) { // go right\n                i++;\n                node = parent.children[i];\n                goingUp = false;\n\n            } else node = null; // nothing found\n        }\n\n        return this;\n    },\n\n    toBBox: function (item) { return item; },\n\n    compareMinX: compareNodeMinX,\n    compareMinY: compareNodeMinY,\n\n    toJSON: function () { return this.data; },\n\n    fromJSON: function (data) {\n        this.data = data;\n        return this;\n    },\n\n    _all: function (node, result) {\n        var nodesToSearch = [];\n        while (node) {\n            if (node.leaf) result.push.apply(result, node.children);\n            else nodesToSearch.push.apply(nodesToSearch, node.children);\n\n            node = nodesToSearch.pop();\n        }\n        return result;\n    },\n\n    _build: function (items, left, right, height) {\n\n        var N = right - left + 1,\n            M = this._maxEntries,\n            node;\n\n        if (N <= M) {\n            // reached leaf level; return leaf\n            node = createNode(items.slice(left, right + 1));\n            calcBBox(node, this.toBBox);\n            return node;\n        }\n\n        if (!height) {\n            // target height of the bulk-loaded tree\n            height = Math.ceil(Math.log(N) / Math.log(M));\n\n            // target number of root entries to maximize storage utilization\n            M = Math.ceil(N / Math.pow(M, height - 1));\n        }\n\n        node = createNode([]);\n        node.leaf = false;\n        node.height = height;\n\n        // split the items into M mostly square tiles\n\n        var N2 = Math.ceil(N / M),\n            N1 = N2 * Math.ceil(Math.sqrt(M)),\n            i, j, right2, right3;\n\n        multiSelect(items, left, right, N1, this.compareMinX);\n\n        for (i = left; i <= right; i += N1) {\n\n            right2 = Math.min(i + N1 - 1, right);\n\n            multiSelect(items, i, right2, N2, this.compareMinY);\n\n            for (j = i; j <= right2; j += N2) {\n\n                right3 = Math.min(j + N2 - 1, right2);\n\n                // pack each entry recursively\n                node.children.push(this._build(items, j, right3, height - 1));\n            }\n        }\n\n        calcBBox(node, this.toBBox);\n\n        return node;\n    },\n\n    _chooseSubtree: function (bbox, node, level, path) {\n\n        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;\n\n        while (true) {\n            path.push(node);\n\n            if (node.leaf || path.length - 1 === level) break;\n\n            minArea = minEnlargement = Infinity;\n\n            for (i = 0, len = node.children.length; i < len; i++) {\n                child = node.children[i];\n                area = bboxArea(child);\n                enlargement = enlargedArea(bbox, child) - area;\n\n                // choose entry with the least area enlargement\n                if (enlargement < minEnlargement) {\n                    minEnlargement = enlargement;\n                    minArea = area < minArea ? area : minArea;\n                    targetNode = child;\n\n                } else if (enlargement === minEnlargement) {\n                    // otherwise choose one with the smallest area\n                    if (area < minArea) {\n                        minArea = area;\n                        targetNode = child;\n                    }\n                }\n            }\n\n            node = targetNode || node.children[0];\n        }\n\n        return node;\n    },\n\n    _insert: function (item, level, isNode) {\n\n        var toBBox = this.toBBox,\n            bbox = isNode ? item : toBBox(item),\n            insertPath = [];\n\n        // find the best node for accommodating the item, saving all nodes along the path too\n        var node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n        // put the item into the node\n        node.children.push(item);\n        extend(node, bbox);\n\n        // split on node overflow; propagate upwards if necessary\n        while (level >= 0) {\n            if (insertPath[level].children.length > this._maxEntries) {\n                this._split(insertPath, level);\n                level--;\n            } else break;\n        }\n\n        // adjust bboxes along the insertion path\n        this._adjustParentBBoxes(bbox, insertPath, level);\n    },\n\n    // split overflowed node into two\n    _split: function (insertPath, level) {\n\n        var node = insertPath[level],\n            M = node.children.length,\n            m = this._minEntries;\n\n        this._chooseSplitAxis(node, m, M);\n\n        var splitIndex = this._chooseSplitIndex(node, m, M);\n\n        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n        newNode.height = node.height;\n        newNode.leaf = node.leaf;\n\n        calcBBox(node, this.toBBox);\n        calcBBox(newNode, this.toBBox);\n\n        if (level) insertPath[level - 1].children.push(newNode);\n        else this._splitRoot(node, newNode);\n    },\n\n    _splitRoot: function (node, newNode) {\n        // split root node\n        this.data = createNode([node, newNode]);\n        this.data.height = node.height + 1;\n        this.data.leaf = false;\n        calcBBox(this.data, this.toBBox);\n    },\n\n    _chooseSplitIndex: function (node, m, M) {\n\n        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;\n\n        minOverlap = minArea = Infinity;\n\n        for (i = m; i <= M - m; i++) {\n            bbox1 = distBBox(node, 0, i, this.toBBox);\n            bbox2 = distBBox(node, i, M, this.toBBox);\n\n            overlap = intersectionArea(bbox1, bbox2);\n            area = bboxArea(bbox1) + bboxArea(bbox2);\n\n            // choose distribution with minimum overlap\n            if (overlap < minOverlap) {\n                minOverlap = overlap;\n                index = i;\n\n                minArea = area < minArea ? area : minArea;\n\n            } else if (overlap === minOverlap) {\n                // otherwise choose distribution with minimum area\n                if (area < minArea) {\n                    minArea = area;\n                    index = i;\n                }\n            }\n        }\n\n        return index;\n    },\n\n    // sorts node children by the best axis for split\n    _chooseSplitAxis: function (node, m, M) {\n\n        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,\n            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,\n            xMargin = this._allDistMargin(node, m, M, compareMinX),\n            yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n        // if total distributions margin value is minimal for x, sort by minX,\n        // otherwise it's already sorted by minY\n        if (xMargin < yMargin) node.children.sort(compareMinX);\n    },\n\n    // total margin of all possible split distributions where each node is at least m full\n    _allDistMargin: function (node, m, M, compare) {\n\n        node.children.sort(compare);\n\n        var toBBox = this.toBBox,\n            leftBBox = distBBox(node, 0, m, toBBox),\n            rightBBox = distBBox(node, M - m, M, toBBox),\n            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),\n            i, child;\n\n        for (i = m; i < M - m; i++) {\n            child = node.children[i];\n            extend(leftBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(leftBBox);\n        }\n\n        for (i = M - m - 1; i >= m; i--) {\n            child = node.children[i];\n            extend(rightBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(rightBBox);\n        }\n\n        return margin;\n    },\n\n    _adjustParentBBoxes: function (bbox, path, level) {\n        // adjust bboxes along the given tree path\n        for (var i = level; i >= 0; i--) {\n            extend(path[i], bbox);\n        }\n    },\n\n    _condense: function (path) {\n        // go through the path, removing empty nodes and updating bboxes\n        for (var i = path.length - 1, siblings; i >= 0; i--) {\n            if (path[i].children.length === 0) {\n                if (i > 0) {\n                    siblings = path[i - 1].children;\n                    siblings.splice(siblings.indexOf(path[i]), 1);\n\n                } else this.clear();\n\n            } else calcBBox(path[i], this.toBBox);\n        }\n    },\n\n    _initFormat: function (format) {\n        // data format (minX, minY, maxX, maxY accessors)\n\n        // uses eval-type function compilation instead of just accepting a toBBox function\n        // because the algorithms are very sensitive to sorting functions performance,\n        // so they should be dead simple and without inner calls\n\n        var compareArr = ['return a', ' - b', ';'];\n\n        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));\n        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));\n\n        this.toBBox = new Function('a',\n            'return {minX: a' + format[0] +\n            ', minY: a' + format[1] +\n            ', maxX: a' + format[2] +\n            ', maxY: a' + format[3] + '};');\n    }\n};\n\nfunction findItem(item, items, equalsFn) {\n    if (!equalsFn) return items.indexOf(item);\n\n    for (var i = 0; i < items.length; i++) {\n        if (equalsFn(item, items[i])) return i;\n    }\n    return -1;\n}\n\n// calculate node's bbox from bboxes of its children\nfunction calcBBox(node, toBBox) {\n    distBBox(node, 0, node.children.length, toBBox, node);\n}\n\n// min bounding rectangle of node children from k to p-1\nfunction distBBox(node, k, p, toBBox, destNode) {\n    if (!destNode) destNode = createNode(null);\n    destNode.minX = Infinity;\n    destNode.minY = Infinity;\n    destNode.maxX = -Infinity;\n    destNode.maxY = -Infinity;\n\n    for (var i = k, child; i < p; i++) {\n        child = node.children[i];\n        extend(destNode, node.leaf ? toBBox(child) : child);\n    }\n\n    return destNode;\n}\n\nfunction extend(a, b) {\n    a.minX = Math.min(a.minX, b.minX);\n    a.minY = Math.min(a.minY, b.minY);\n    a.maxX = Math.max(a.maxX, b.maxX);\n    a.maxY = Math.max(a.maxY, b.maxY);\n    return a;\n}\n\nfunction compareNodeMinX(a, b) { return a.minX - b.minX; }\nfunction compareNodeMinY(a, b) { return a.minY - b.minY; }\n\nfunction bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }\nfunction bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }\n\nfunction enlargedArea(a, b) {\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\n           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\n\nfunction intersectionArea(a, b) {\n    var minX = Math.max(a.minX, b.minX),\n        minY = Math.max(a.minY, b.minY),\n        maxX = Math.min(a.maxX, b.maxX),\n        maxY = Math.min(a.maxY, b.maxY);\n\n    return Math.max(0, maxX - minX) *\n           Math.max(0, maxY - minY);\n}\n\nfunction contains(a, b) {\n    return a.minX <= b.minX &&\n           a.minY <= b.minY &&\n           b.maxX <= a.maxX &&\n           b.maxY <= a.maxY;\n}\n\nfunction intersects(a, b) {\n    return b.minX <= a.maxX &&\n           b.minY <= a.maxY &&\n           b.maxX >= a.minX &&\n           b.maxY >= a.minY;\n}\n\nfunction createNode(children) {\n    return {\n        children: children,\n        height: 1,\n        leaf: true,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n}\n\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\nfunction multiSelect(arr, left, right, n, compare) {\n    var stack = [left, right],\n        mid;\n\n    while (stack.length) {\n        right = stack.pop();\n        left = stack.pop();\n\n        if (right - left <= n) continue;\n\n        mid = left + Math.ceil((right - left) / n / 2) * n;\n        quickselect(arr, mid, left, right, compare);\n\n        stack.push(left, mid, mid, right);\n    }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar meta_1 = require(\"@turf/meta\");\n/**\n * Takes a set of features, calculates the bbox of all input features, and returns a bounding box.\n *\n * @name bbox\n * @param {GeoJSON} geojson any GeoJSON object\n * @returns {BBox} bbox extent in [minX, minY, maxX, maxY] order\n * @example\n * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]]);\n * var bbox = turf.bbox(line);\n * var bboxPolygon = turf.bboxPolygon(bbox);\n *\n * //addToMap\n * var addToMap = [line, bboxPolygon]\n */\nfunction bbox(geojson) {\n    var result = [Infinity, Infinity, -Infinity, -Infinity];\n    meta_1.coordEach(geojson, function (coord) {\n        if (result[0] > coord[0]) {\n            result[0] = coord[0];\n        }\n        if (result[1] > coord[1]) {\n            result[1] = coord[1];\n        }\n        if (result[2] < coord[0]) {\n            result[2] = coord[0];\n        }\n        if (result[3] < coord[1]) {\n            result[3] = coord[1];\n        }\n    });\n    return result;\n}\nexports.default = bbox;\n","var rbush = require('rbush');\nvar helpers = require('@turf/helpers');\nvar meta = require('@turf/meta');\nvar turfBBox = require('@turf/bbox').default;\nvar featureEach = meta.featureEach;\nvar coordEach = meta.coordEach;\nvar polygon = helpers.polygon;\nvar featureCollection = helpers.featureCollection;\n\n/**\n * GeoJSON implementation of [RBush](https://github.com/mourner/rbush#rbush) spatial index.\n *\n * @name rbush\n * @param {number} [maxEntries=9] defines the maximum number of entries in a tree node. 9 (used by default) is a\n * reasonable choice for most applications. Higher value means faster insertion and slower search, and vice versa.\n * @returns {RBush} GeoJSON RBush\n * @example\n * var geojsonRbush = require('geojson-rbush').default;\n * var tree = geojsonRbush();\n */\nfunction geojsonRbush(maxEntries) {\n    var tree = rbush(maxEntries);\n    /**\n     * [insert](https://github.com/mourner/rbush#data-format)\n     *\n     * @param {Feature} feature insert single GeoJSON Feature\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);\n     * tree.insert(poly)\n     */\n    tree.insert = function (feature) {\n        if (feature.type !== 'Feature') throw new Error('invalid feature');\n        feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n        return rbush.prototype.insert.call(this, feature);\n    };\n\n    /**\n     * [load](https://github.com/mourner/rbush#bulk-inserting-data)\n     *\n     * @param {FeatureCollection|Array<Feature>} features load entire GeoJSON FeatureCollection\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var polys = turf.polygons([\n     *     [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]],\n     *     [[[-93, 32], [-83, 32], [-83, 39], [-93, 39], [-93, 32]]]\n     * ]);\n     * tree.load(polys);\n     */\n    tree.load = function (features) {\n        var load = [];\n        // Load an Array of Features\n        if (Array.isArray(features)) {\n            features.forEach(function (feature) {\n                if (feature.type !== 'Feature') throw new Error('invalid features');\n                feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n                load.push(feature);\n            });\n        } else {\n            // Load a FeatureCollection\n            featureEach(features, function (feature) {\n                if (feature.type !== 'Feature') throw new Error('invalid features');\n                feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n                load.push(feature);\n            });\n        }\n        return rbush.prototype.load.call(this, load);\n    };\n\n    /**\n     * [remove](https://github.com/mourner/rbush#removing-data)\n     *\n     * @param {Feature} feature remove single GeoJSON Feature\n     * @param {Function} equals Pass a custom equals function to compare by value for removal.\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);\n     *\n     * tree.remove(poly);\n     */\n    tree.remove = function (feature, equals) {\n        if (feature.type !== 'Feature') throw new Error('invalid feature');\n        feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n        return rbush.prototype.remove.call(this, feature, equals);\n    };\n\n    /**\n     * [clear](https://github.com/mourner/rbush#removing-data)\n     *\n     * @returns {RBush} GeoJSON Rbush\n     * @example\n     * tree.clear()\n     */\n    tree.clear = function () {\n        return rbush.prototype.clear.call(this);\n    };\n\n    /**\n     * [search](https://github.com/mourner/rbush#search)\n     *\n     * @param {BBox|FeatureCollection|Feature} geojson search with GeoJSON\n     * @returns {FeatureCollection} all features that intersects with the given GeoJSON.\n     * @example\n     * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);\n     *\n     * tree.search(poly);\n     */\n    tree.search = function (geojson) {\n        var features = rbush.prototype.search.call(this, this.toBBox(geojson));\n        return featureCollection(features);\n    };\n\n    /**\n     * [collides](https://github.com/mourner/rbush#collisions)\n     *\n     * @param {BBox|FeatureCollection|Feature} geojson collides with GeoJSON\n     * @returns {boolean} true if there are any items intersecting the given GeoJSON, otherwise false.\n     * @example\n     * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);\n     *\n     * tree.collides(poly);\n     */\n    tree.collides = function (geojson) {\n        return rbush.prototype.collides.call(this, this.toBBox(geojson));\n    };\n\n    /**\n     * [all](https://github.com/mourner/rbush#search)\n     *\n     * @returns {FeatureCollection} all the features in RBush\n     * @example\n     * tree.all()\n     */\n    tree.all = function () {\n        var features = rbush.prototype.all.call(this);\n        return featureCollection(features);\n    };\n\n    /**\n     * [toJSON](https://github.com/mourner/rbush#export-and-import)\n     *\n     * @returns {any} export data as JSON object\n     * @example\n     * var exported = tree.toJSON()\n     */\n    tree.toJSON = function () {\n        return rbush.prototype.toJSON.call(this);\n    };\n\n    /**\n     * [fromJSON](https://github.com/mourner/rbush#export-and-import)\n     *\n     * @param {any} json import previously exported data\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var exported = {\n     *   \"children\": [\n     *     {\n     *       \"type\": \"Feature\",\n     *       \"geometry\": {\n     *         \"type\": \"Point\",\n     *         \"coordinates\": [110, 50]\n     *       },\n     *       \"properties\": {},\n     *       \"bbox\": [110, 50, 110, 50]\n     *     }\n     *   ],\n     *   \"height\": 1,\n     *   \"leaf\": true,\n     *   \"minX\": 110,\n     *   \"minY\": 50,\n     *   \"maxX\": 110,\n     *   \"maxY\": 50\n     * }\n     * tree.fromJSON(exported)\n     */\n    tree.fromJSON = function (json) {\n        return rbush.prototype.fromJSON.call(this, json);\n    };\n\n    /**\n     * Converts GeoJSON to {minX, minY, maxX, maxY} schema\n     *\n     * @private\n     * @param {BBox|FeatureCollection|Feature} geojson feature(s) to retrieve BBox from\n     * @returns {Object} converted to {minX, minY, maxX, maxY}\n     */\n    tree.toBBox = function (geojson) {\n        var bbox;\n        if (geojson.bbox) bbox = geojson.bbox;\n        else if (Array.isArray(geojson) && geojson.length === 4) bbox = geojson;\n        else if (Array.isArray(geojson) && geojson.length === 6) bbox = [geojson[0], geojson[1], geojson[3], geojson[4]];\n        else if (geojson.type === 'Feature') bbox = turfBBox(geojson);\n        else if (geojson.type === 'FeatureCollection') bbox = turfBBox(geojson);\n        else throw new Error('invalid geojson')\n\n        return {\n            minX: bbox[0],\n            minY: bbox[1],\n            maxX: bbox[2],\n            maxY: bbox[3]\n        };\n    };\n    return tree;\n}\n\nmodule.exports = geojsonRbush;\nmodule.exports.default = geojsonRbush;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar helpers_1 = require(\"@turf/helpers\");\nvar invariant_1 = require(\"@turf/invariant\");\nvar line_segment_1 = __importDefault(require(\"@turf/line-segment\"));\nvar meta_1 = require(\"@turf/meta\");\nvar geojson_rbush_1 = __importDefault(require(\"geojson-rbush\"));\n/**\n * Takes any LineString or Polygon GeoJSON and returns the intersecting point(s).\n *\n * @name lineIntersect\n * @param {GeoJSON} line1 any LineString or Polygon\n * @param {GeoJSON} line2 any LineString or Polygon\n * @returns {FeatureCollection<Point>} point(s) that intersect both\n * @example\n * var line1 = turf.lineString([[126, -11], [129, -21]]);\n * var line2 = turf.lineString([[123, -18], [131, -14]]);\n * var intersects = turf.lineIntersect(line1, line2);\n *\n * //addToMap\n * var addToMap = [line1, line2, intersects]\n */\nfunction lineIntersect(line1, line2) {\n    var unique = {};\n    var results = [];\n    // First, normalize geometries to features\n    // Then, handle simple 2-vertex segments\n    if (line1.type === \"LineString\") {\n        line1 = helpers_1.feature(line1);\n    }\n    if (line2.type === \"LineString\") {\n        line2 = helpers_1.feature(line2);\n    }\n    if (line1.type === \"Feature\" &&\n        line2.type === \"Feature\" &&\n        line1.geometry !== null &&\n        line2.geometry !== null &&\n        line1.geometry.type === \"LineString\" &&\n        line2.geometry.type === \"LineString\" &&\n        line1.geometry.coordinates.length === 2 &&\n        line2.geometry.coordinates.length === 2) {\n        var intersect = intersects(line1, line2);\n        if (intersect) {\n            results.push(intersect);\n        }\n        return helpers_1.featureCollection(results);\n    }\n    // Handles complex GeoJSON Geometries\n    var tree = geojson_rbush_1.default();\n    tree.load(line_segment_1.default(line2));\n    meta_1.featureEach(line_segment_1.default(line1), function (segment) {\n        meta_1.featureEach(tree.search(segment), function (match) {\n            var intersect = intersects(segment, match);\n            if (intersect) {\n                // prevent duplicate points https://github.com/Turfjs/turf/issues/688\n                var key = invariant_1.getCoords(intersect).join(\",\");\n                if (!unique[key]) {\n                    unique[key] = true;\n                    results.push(intersect);\n                }\n            }\n        });\n    });\n    return helpers_1.featureCollection(results);\n}\n/**\n * Find a point that intersects LineStrings with two coordinates each\n *\n * @private\n * @param {Feature<LineString>} line1 GeoJSON LineString (Must only contain 2 coordinates)\n * @param {Feature<LineString>} line2 GeoJSON LineString (Must only contain 2 coordinates)\n * @returns {Feature<Point>} intersecting GeoJSON Point\n */\nfunction intersects(line1, line2) {\n    var coords1 = invariant_1.getCoords(line1);\n    var coords2 = invariant_1.getCoords(line2);\n    if (coords1.length !== 2) {\n        throw new Error(\"<intersects> line1 must only contain 2 coordinates\");\n    }\n    if (coords2.length !== 2) {\n        throw new Error(\"<intersects> line2 must only contain 2 coordinates\");\n    }\n    var x1 = coords1[0][0];\n    var y1 = coords1[0][1];\n    var x2 = coords1[1][0];\n    var y2 = coords1[1][1];\n    var x3 = coords2[0][0];\n    var y3 = coords2[0][1];\n    var x4 = coords2[1][0];\n    var y4 = coords2[1][1];\n    var denom = ((y4 - y3) * (x2 - x1)) - ((x4 - x3) * (y2 - y1));\n    var numeA = ((x4 - x3) * (y1 - y3)) - ((y4 - y3) * (x1 - x3));\n    var numeB = ((x2 - x1) * (y1 - y3)) - ((y2 - y1) * (x1 - x3));\n    if (denom === 0) {\n        if (numeA === 0 && numeB === 0) {\n            return null;\n        }\n        return null;\n    }\n    var uA = numeA / denom;\n    var uB = numeB / denom;\n    if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {\n        var x = x1 + (uA * (x2 - x1));\n        var y = y1 + (uA * (y2 - y1));\n        return helpers_1.point([x, y]);\n    }\n    return null;\n}\nexports.default = lineIntersect;\n","/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n */\nvar earthRadius = 6371008.8;\n\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n */\nvar factors = {\n    meters: earthRadius,\n    metres: earthRadius,\n    millimeters: earthRadius * 1000,\n    millimetres: earthRadius * 1000,\n    centimeters: earthRadius * 100,\n    centimetres: earthRadius * 100,\n    kilometers: earthRadius / 1000,\n    kilometres: earthRadius / 1000,\n    miles: earthRadius / 1609.344,\n    nauticalmiles: earthRadius / 1852,\n    inches: earthRadius * 39.370,\n    yards: earthRadius / 1.0936,\n    feet: earthRadius * 3.28084,\n    radians: 1,\n    degrees: earthRadius / 111325,\n};\n\n/**\n * Units of measurement factors based on 1 meter.\n */\nvar unitsFactors = {\n    meters: 1,\n    metres: 1,\n    millimeters: 1000,\n    millimetres: 1000,\n    centimeters: 100,\n    centimetres: 100,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    miles: 1 / 1609.344,\n    nauticalmiles: 1 / 1852,\n    inches: 39.370,\n    yards: 1 / 1.0936,\n    feet: 3.28084,\n    radians: 1 / earthRadius,\n    degrees: 1 / 111325,\n};\n\n/**\n * Area of measurement factors based on 1 square meter.\n */\nvar areaFactors = {\n    meters: 1,\n    metres: 1,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    centimeters: 10000,\n    centimetres: 10000,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    acres: 0.000247105,\n    miles: 3.86e-7,\n    yards: 1.195990046,\n    feet: 10.763910417,\n    inches: 1550.003100006\n};\n\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geometry, properties, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n    var id = options.id;\n\n    // Validation\n    if (geometry === undefined) throw new Error('geometry is required');\n    if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');\n    if (bbox) validateBBox(bbox);\n    if (id) validateId(id);\n\n    // Main\n    var feat = {type: 'Feature'};\n    if (id) feat.id = id;\n    if (bbox) feat.bbox = bbox;\n    feat.properties = properties || {};\n    feat.geometry = geometry;\n    return feat;\n}\n\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<number>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Geometry\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = 'Point';\n * var coordinates = [110, 50];\n *\n * var geometry = turf.geometry(type, coordinates);\n *\n * //=geometry\n */\nfunction geometry(type, coordinates, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n\n    // Validation\n    if (!type) throw new Error('type is required');\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (bbox) validateBBox(bbox);\n\n    // Main\n    var geom;\n    switch (type) {\n    case 'Point': geom = point(coordinates).geometry; break;\n    case 'LineString': geom = lineString(coordinates).geometry; break;\n    case 'Polygon': geom = polygon(coordinates).geometry; break;\n    case 'MultiPoint': geom = multiPoint(coordinates).geometry; break;\n    case 'MultiLineString': geom = multiLineString(coordinates).geometry; break;\n    case 'MultiPolygon': geom = multiPolygon(coordinates).geometry; break;\n    default: throw new Error(type + ' is invalid');\n    }\n    if (bbox) geom.bbox = bbox;\n    return geom;\n}\n\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (coordinates.length < 2) throw new Error('coordinates must be at least 2 numbers long');\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) throw new Error('coordinates must contain numbers');\n\n    return feature({\n        type: 'Point',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\n\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    for (var i = 0; i < coordinates.length; i++) {\n        var ring = coordinates[i];\n        if (ring.length < 4) {\n            throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (i === 0 && j === 0 && !isNumber(ring[0][0]) || !isNumber(ring[0][1])) throw new Error('coordinates must contain numbers');\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error('First and last Position are not equivalent.');\n            }\n        }\n    }\n\n    return feature({\n        type: 'Polygon',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\n\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (coordinates.length < 2) throw new Error('coordinates must be an array of two or more positions');\n    // Check if first point of LineString contains two numbers\n    if (!isNumber(coordinates[0][1]) || !isNumber(coordinates[0][1])) throw new Error('coordinates must contain numbers');\n\n    return feature({\n        type: 'LineString',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<number>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\n\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n    var id = options.id;\n\n    // Validation\n    if (!features) throw new Error('No features passed');\n    if (!Array.isArray(features)) throw new Error('features must be an Array');\n    if (bbox) validateBBox(bbox);\n    if (id) validateId(id);\n\n    // Main\n    var fc = {type: 'FeatureCollection'};\n    if (id) fc.id = id;\n    if (bbox) fc.bbox = bbox;\n    fc.features = features;\n    return fc;\n}\n\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiLineString',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiPoint',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiPolygon',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = {\n *     \"type\": \"Point\",\n *       \"coordinates\": [100, 0]\n *     };\n * var line = {\n *     \"type\": \"LineString\",\n *     \"coordinates\": [ [101, 0], [102, 1] ]\n *   };\n * var collection = turf.geometryCollection([pt, line]);\n *\n * //=collection\n */\nfunction geometryCollection(geometries, properties, options) {\n    if (!geometries) throw new Error('geometries is required');\n    if (!Array.isArray(geometries)) throw new Error('geometries must be an Array');\n\n    return feature({\n        type: 'GeometryCollection',\n        geometries: geometries\n    }, properties, options);\n}\n\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (num === undefined || num === null || isNaN(num)) throw new Error('num is required');\n    if (precision && !(precision >= 0)) throw new Error('precision must be a positive number');\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (radians === undefined || radians === null) throw new Error('radians is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return radians * factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (distance === undefined || distance === null) throw new Error('distance is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return distance / factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\n\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n    if (bearing === null || bearing === undefined) throw new Error('bearing is required');\n\n    var angle = bearing % 360;\n    if (angle < 0) angle += 360;\n    return angle;\n}\n\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n    if (radians === null || radians === undefined) throw new Error('radians is required');\n\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\n\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    if (degrees === null || degrees === undefined) throw new Error('degrees is required');\n\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\n\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {string} originalUnit of the length\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n    if (length === null || length === undefined) throw new Error('length is required');\n    if (!(length >= 0)) throw new Error('length must be a positive number');\n\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit || 'kilometers');\n}\n\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches\n * @param {number} area to be converted\n * @param {string} [originalUnit='meters'] of the distance\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted distance\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n    if (area === null || area === undefined) throw new Error('area is required');\n    if (!(area >= 0)) throw new Error('area must be a positive number');\n\n    var startFactor = areaFactors[originalUnit || 'meters'];\n    if (!startFactor) throw new Error('invalid original units');\n\n    var finalFactor = areaFactors[finalUnit || 'kilometers'];\n    if (!finalFactor) throw new Error('invalid final units');\n\n    return (area / startFactor) * finalFactor;\n}\n\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n    return (!!input) && (input.constructor === Object);\n}\n\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n    if (!bbox) throw new Error('bbox is required');\n    if (!Array.isArray(bbox)) throw new Error('bbox must be an Array');\n    if (bbox.length !== 4 && bbox.length !== 6) throw new Error('bbox must be an Array of 4 or 6 numbers');\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) throw new Error('bbox must only contain numbers');\n    });\n}\n\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n    if (!id) throw new Error('id is required');\n    if (['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');\n}\n\n// Deprecated methods\nfunction radians2degrees() {\n    throw new Error('method has been renamed to `radiansToDegrees`');\n}\n\nfunction degrees2radians() {\n    throw new Error('method has been renamed to `degreesToRadians`');\n}\n\nfunction distanceToDegrees() {\n    throw new Error('method has been renamed to `lengthToDegrees`');\n}\n\nfunction distanceToRadians() {\n    throw new Error('method has been renamed to `lengthToRadians`');\n}\n\nfunction radiansToDistance() {\n    throw new Error('method has been renamed to `radiansToLength`');\n}\n\nfunction bearingToAngle() {\n    throw new Error('method has been renamed to `bearingToAzimuth`');\n}\n\nfunction convertDistance() {\n    throw new Error('method has been renamed to `convertLength`');\n}\n\nexport { earthRadius, factors, unitsFactors, areaFactors, feature, geometry, point, points, polygon, polygons, lineString, lineStrings, featureCollection, multiLineString, multiPoint, multiPolygon, geometryCollection, round, radiansToLength, lengthToRadians, lengthToDegrees, bearingToAzimuth, radiansToDegrees, degreesToRadians, convertLength, convertArea, isNumber, isObject, validateBBox, validateId, radians2degrees, degrees2radians, distanceToDegrees, distanceToRadians, radiansToDistance, bearingToAngle, convertDistance };\n","import { feature, isObject, lineString, point } from '@turf/helpers';\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n    // Handles null Geometry -- Skips this GeoJSON\n    if (geojson === null) return;\n    var j, k, l, geometry, stopG, coords,\n        geometryMaybeCollection,\n        wrapShrink = 0,\n        coordIndex = 0,\n        isGeometryCollection,\n        type = geojson.type,\n        isFeatureCollection = type === 'FeatureCollection',\n        isFeature = type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n            var multiFeatureIndex = 0;\n            var geometryIndex = 0;\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n\n            // Handles null Geometry -- Skips this geometry\n            if (geometry === null) continue;\n            coords = geometry.coordinates;\n            var geomType = geometry.type;\n\n            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;\n\n            switch (geomType) {\n            case null:\n                break;\n            case 'Point':\n                if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                coordIndex++;\n                multiFeatureIndex++;\n                break;\n            case 'LineString':\n            case 'MultiPoint':\n                for (j = 0; j < coords.length; j++) {\n                    if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                    coordIndex++;\n                    if (geomType === 'MultiPoint') multiFeatureIndex++;\n                }\n                if (geomType === 'LineString') multiFeatureIndex++;\n                break;\n            case 'Polygon':\n            case 'MultiLineString':\n                for (j = 0; j < coords.length; j++) {\n                    for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                        if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                        coordIndex++;\n                    }\n                    if (geomType === 'MultiLineString') multiFeatureIndex++;\n                    if (geomType === 'Polygon') geometryIndex++;\n                }\n                if (geomType === 'Polygon') multiFeatureIndex++;\n                break;\n            case 'MultiPolygon':\n                for (j = 0; j < coords.length; j++) {\n                    if (geomType === 'MultiPolygon') geometryIndex = 0;\n                    for (k = 0; k < coords[j].length; k++) {\n                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                            if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                            coordIndex++;\n                        }\n                        geometryIndex++;\n                    }\n                    multiFeatureIndex++;\n                }\n                break;\n            case 'GeometryCollection':\n                for (j = 0; j < geometry.geometries.length; j++)\n                    if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;\n                break;\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n    var previousValue = initialValue;\n    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;\n        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n    }, excludeWrapCoord);\n    return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n    var i;\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        for (i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i].properties, i) === false) break;\n        }\n        break;\n    case 'Feature':\n        callback(geojson.properties, 0);\n        break;\n    }\n}\n\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    propEach(geojson, function (currentProperties, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;\n        else previousValue = callback(previousValue, currentProperties, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n    if (geojson.type === 'Feature') {\n        callback(geojson, 0);\n    } else if (geojson.type === 'FeatureCollection') {\n        for (var i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i], i) === false) break;\n        }\n    }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    featureEach(geojson, function (currentFeature, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n    var coords = [];\n    coordEach(geojson, function (coord) {\n        coords.push(coord);\n    });\n    return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n    var i, j, g, geometry, stopG,\n        geometryMaybeCollection,\n        isGeometryCollection,\n        featureProperties,\n        featureBBox,\n        featureId,\n        featureIndex = 0,\n        isFeatureCollection = geojson.type === 'FeatureCollection',\n        isFeature = geojson.type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        featureProperties = (isFeatureCollection ? geojson.features[i].properties :\n            (isFeature ? geojson.properties : {}));\n        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :\n            (isFeature ? geojson.bbox : undefined));\n        featureId = (isFeatureCollection ? geojson.features[i].id :\n            (isFeature ? geojson.id : undefined));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n            // Handle null Geometry\n            if (geometry === null) {\n                if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                continue;\n            }\n            switch (geometry.type) {\n            case 'Point':\n            case 'LineString':\n            case 'MultiPoint':\n            case 'Polygon':\n            case 'MultiLineString':\n            case 'MultiPolygon': {\n                if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                break;\n            }\n            case 'GeometryCollection': {\n                for (j = 0; j < geometry.geometries.length; j++) {\n                    if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                }\n                break;\n            }\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n        // Only increase `featureIndex` per each feature\n        featureIndex++;\n    }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;\n        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n    geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n        // Callback for single geometry\n        var type = (geometry === null) ? null : geometry.type;\n        switch (type) {\n        case null:\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n            if (callback(feature(geometry, properties, {bbox: bbox, id: id}), featureIndex, 0) === false) return false;\n            return;\n        }\n\n        var geomType;\n\n        // Callback for multi-geometry\n        switch (type) {\n        case 'MultiPoint':\n            geomType = 'Point';\n            break;\n        case 'MultiLineString':\n            geomType = 'LineString';\n            break;\n        case 'MultiPolygon':\n            geomType = 'Polygon';\n            break;\n        }\n\n        for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n            var coordinate = geometry.coordinates[multiFeatureIndex];\n            var geom = {\n                type: geomType,\n                coordinates: coordinate\n            };\n            if (callback(feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;\n        }\n    });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {\n        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n    flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {\n        var segmentIndex = 0;\n\n        // Exclude null Geometries\n        if (!feature$$1.geometry) return;\n        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n        var type = feature$$1.geometry.type;\n        if (type === 'Point' || type === 'MultiPoint') return;\n\n        // Generate 2-vertex line segments\n        var previousCoords;\n        if (coordEach(feature$$1, function (currentCoord, coordIndex, featureIndexCoord, mutliPartIndexCoord, geometryIndex) {\n            // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n            if (previousCoords === undefined) {\n                previousCoords = currentCoord;\n                return;\n            }\n            var currentSegment = lineString([previousCoords, currentCoord], feature$$1.properties);\n            if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;\n            segmentIndex++;\n            previousCoords = currentCoord;\n        }) === false) return false;\n    });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentInex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    var started = false;\n    segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n        if (started === false && initialValue === undefined) previousValue = currentSegment;\n        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\n        started = true;\n    });\n    return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n    // validation\n    if (!geojson) throw new Error('geojson is required');\n\n    flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {\n        if (feature$$1.geometry === null) return;\n        var type = feature$$1.geometry.type;\n        var coords = feature$$1.geometry.coordinates;\n        switch (type) {\n        case 'LineString':\n            if (callback(feature$$1, featureIndex, multiFeatureIndex, 0, 0) === false) return false;\n            break;\n        case 'Polygon':\n            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n                if (callback(lineString(coords[geometryIndex], feature$$1.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n            }\n            break;\n        }\n    });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;\n        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var segmentIndex = options.segmentIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find SegmentIndex\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n        if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n        return lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n        return lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n        return lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n        return lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var coordIndex = options.coordIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find Coord Index\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n        return point(coords, properties, options);\n    case 'MultiPoint':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        return point(coords[multiFeatureIndex], properties, options);\n    case 'LineString':\n        if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n        return point(coords[coordIndex], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;\n        return point(coords[geometryIndex][coordIndex], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;\n        return point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n        return point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\nexport { coordEach, coordReduce, propEach, propReduce, featureEach, featureReduce, coordAll, geomEach, geomReduce, flattenEach, flattenReduce, segmentEach, segmentReduce, lineEach, lineReduce, findSegment, findPoint };\n","import { isNumber } from '@turf/helpers';\n\n/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nfunction getCoord(coord) {\n    if (!coord) throw new Error('coord is required');\n    if (coord.type === 'Feature' && coord.geometry !== null && coord.geometry.type === 'Point') return coord.geometry.coordinates;\n    if (coord.type === 'Point') return coord.coordinates;\n    if (Array.isArray(coord) && coord.length >= 2 && coord[0].length === undefined && coord[1].length === undefined) return coord;\n\n    throw new Error('coord must be GeoJSON Point or an Array of numbers');\n}\n\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array\n *\n * @name getCoords\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\n * @returns {Array<any>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coords = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nfunction getCoords(coords) {\n    if (!coords) throw new Error('coords is required');\n\n    // Feature\n    if (coords.type === 'Feature' && coords.geometry !== null) return coords.geometry.coordinates;\n\n    // Geometry\n    if (coords.coordinates) return coords.coordinates;\n\n    // Array of numbers\n    if (Array.isArray(coords)) return coords;\n\n    throw new Error('coords must be GeoJSON Feature, Geometry Object or an Array');\n}\n\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nfunction containsNumber(coordinates) {\n    if (coordinates.length > 1 && isNumber(coordinates[0]) && isNumber(coordinates[1])) {\n        return true;\n    }\n\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error('coordinates must only contain numbers');\n}\n\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nfunction geojsonType(value, type, name) {\n    if (!type || !name) throw new Error('type and name required');\n\n    if (!value || value.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + value.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nfunction featureOf(feature, type, name) {\n    if (!feature) throw new Error('No feature passed');\n    if (!name) throw new Error('.featureOf() requires a name');\n    if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n        throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nfunction collectionOf(featureCollection, type, name) {\n    if (!featureCollection) throw new Error('No featureCollection passed');\n    if (!name) throw new Error('.collectionOf() requires a name');\n    if (!featureCollection || featureCollection.type !== 'FeatureCollection') {\n        throw new Error('Invalid input to ' + name + ', FeatureCollection required');\n    }\n    for (var i = 0; i < featureCollection.features.length; i++) {\n        var feature = featureCollection.features[i];\n        if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n            throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n        }\n    }\n}\n\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nfunction getGeom(geojson) {\n    if (!geojson) throw new Error('geojson is required');\n    if (geojson.geometry !== undefined) return geojson.geometry;\n    if (geojson.coordinates || geojson.geometries) return geojson;\n    throw new Error('geojson must be a valid Feature or Geometry Object');\n}\n\n/**\n * Get Geometry Type from Feature or Geometry Object\n *\n * @throws {Error} **DEPRECATED** in v5.0.0 in favor of getType\n */\nfunction getGeomType() {\n    throw new Error('invariant.getGeomType has been deprecated in v5.0 in favor of invariant.getType');\n}\n\n/**\n * Get GeoJSON object's type, Geometry type is prioritize.\n *\n * @param {GeoJSON} geojson GeoJSON object\n * @param {string} [name=\"geojson\"] name of the variable to display in error message\n * @returns {string} GeoJSON type\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getType(point)\n * //=\"Point\"\n */\nfunction getType(geojson, name) {\n    if (!geojson) throw new Error((name || 'geojson') + ' is required');\n    // GeoJSON Feature & GeometryCollection\n    if (geojson.geometry && geojson.geometry.type) return geojson.geometry.type;\n    // GeoJSON Geometry & FeatureCollection\n    if (geojson.type) return geojson.type;\n    throw new Error((name || 'geojson') + ' is invalid');\n}\n\nexport { getCoord, getCoords, containsNumber, geojsonType, featureOf, collectionOf, getGeom, getGeomType, getType };\n","import { flattenEach } from '@turf/meta';\nimport { getCoords, getType } from '@turf/invariant';\nimport { isObject, lengthToDegrees, lineString, multiLineString } from '@turf/helpers';\n\n/**\n * https://github.com/rook2pawn/node-intersection\n *\n * Author @rook2pawn\n */\n\n/**\n * AB\n *\n * @private\n * @param {Array<Array<number>>} segment - 2 vertex line segment\n * @returns {Array<number>} coordinates [x, y]\n */\nfunction ab(segment) {\n    var start = segment[0];\n    var end = segment[1];\n    return [end[0] - start[0], end[1] - start[1]];\n}\n\n/**\n * Cross Product\n *\n * @private\n * @param {Array<number>} v1 coordinates [x, y]\n * @param {Array<number>} v2 coordinates [x, y]\n * @returns {Array<number>} Cross Product\n */\nfunction crossProduct(v1, v2) {\n    return (v1[0] * v2[1]) - (v2[0] * v1[1]);\n}\n\n/**\n * Add\n *\n * @private\n * @param {Array<number>} v1 coordinates [x, y]\n * @param {Array<number>} v2 coordinates [x, y]\n * @returns {Array<number>} Add\n */\nfunction add(v1, v2) {\n    return [v1[0] + v2[0], v1[1] + v2[1]];\n}\n\n/**\n * Sub\n *\n * @private\n * @param {Array<number>} v1 coordinates [x, y]\n * @param {Array<number>} v2 coordinates [x, y]\n * @returns {Array<number>} Sub\n */\nfunction sub(v1, v2) {\n    return [v1[0] - v2[0], v1[1] - v2[1]];\n}\n\n/**\n * scalarMult\n *\n * @private\n * @param {number} s scalar\n * @param {Array<number>} v coordinates [x, y]\n * @returns {Array<number>} scalarMult\n */\nfunction scalarMult(s, v) {\n    return [s * v[0], s * v[1]];\n}\n\n/**\n * Intersect Segments\n *\n * @private\n * @param {Array<number>} a coordinates [x, y]\n * @param {Array<number>} b coordinates [x, y]\n * @returns {Array<number>} intersection\n */\nfunction intersectSegments(a, b) {\n    var p = a[0];\n    var r = ab(a);\n    var q = b[0];\n    var s = ab(b);\n\n    var cross = crossProduct(r, s);\n    var qmp = sub(q, p);\n    var numerator = crossProduct(qmp, s);\n    var t = numerator / cross;\n    var intersection = add(p, scalarMult(t, r));\n    return intersection;\n}\n\n/**\n * Is Parallel\n *\n * @private\n * @param {Array<number>} a coordinates [x, y]\n * @param {Array<number>} b coordinates [x, y]\n * @returns {boolean} true if a and b are parallel (or co-linear)\n */\nfunction isParallel(a, b) {\n    var r = ab(a);\n    var s = ab(b);\n    return (crossProduct(r, s) === 0);\n}\n\n/**\n * Intersection\n *\n * @private\n * @param {Array<number>} a coordinates [x, y]\n * @param {Array<number>} b coordinates [x, y]\n * @returns {Array<number>|boolean} true if a and b are parallel (or co-linear)\n */\nfunction intersection(a, b) {\n    if (isParallel(a, b)) return false;\n    return intersectSegments(a, b);\n}\n\n/**\n * Takes a {@link LineString|line} and returns a {@link LineString|line} at offset by the specified distance.\n *\n * @name lineOffset\n * @param {Geometry|Feature<LineString|MultiLineString>} geojson input GeoJSON\n * @param {number} distance distance to offset the line (can be of negative value)\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, kilometers, inches, yards, meters\n * @returns {Feature<LineString|MultiLineString>} Line offset from the input line\n * @example\n * var line = turf.lineString([[-83, 30], [-84, 36], [-78, 41]], { \"stroke\": \"#F00\" });\n *\n * var offsetLine = turf.lineOffset(line, 2, {units: 'miles'});\n *\n * //addToMap\n * var addToMap = [offsetLine, line]\n * offsetLine.properties.stroke = \"#00F\"\n */\nfunction lineOffset(geojson, distance, options) {\n    // Optional parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var units = options.units;\n\n    // Valdiation\n    if (!geojson) throw new Error('geojson is required');\n    if (distance === undefined || distance === null || isNaN(distance)) throw new Error('distance is required');\n\n    var type = getType(geojson);\n    var properties = geojson.properties;\n\n    switch (type) {\n    case 'LineString':\n        return lineOffsetFeature(geojson, distance, units);\n    case 'MultiLineString':\n        var coords = [];\n        flattenEach(geojson, function (feature) {\n            coords.push(lineOffsetFeature(feature, distance, units).geometry.coordinates);\n        });\n        return multiLineString(coords, properties);\n    default:\n        throw new Error('geometry ' + type + ' is not supported');\n    }\n}\n\n/**\n * Line Offset\n *\n * @private\n * @param {Geometry|Feature<LineString>} line input line\n * @param {number} distance distance to offset the line (can be of negative value)\n * @param {string} [units=kilometers] units\n * @returns {Feature<LineString>} Line offset from the input line\n */\nfunction lineOffsetFeature(line, distance, units) {\n    var segments = [];\n    var offsetDegrees = lengthToDegrees(distance, units);\n    var coords = getCoords(line);\n    var finalCoords = [];\n    coords.forEach(function (currentCoords, index) {\n        if (index !== coords.length - 1) {\n            var segment = processSegment(currentCoords, coords[index + 1], offsetDegrees);\n            segments.push(segment);\n            if (index > 0) {\n                var seg2Coords = segments[index - 1];\n                var intersects = intersection(segment, seg2Coords);\n\n                // Handling for line segments that aren't straight\n                if (intersects !== false) {\n                    seg2Coords[1] = intersects;\n                    segment[0] = intersects;\n                }\n\n                finalCoords.push(seg2Coords[0]);\n                if (index === coords.length - 2) {\n                    finalCoords.push(segment[0]);\n                    finalCoords.push(segment[1]);\n                }\n            }\n            // Handling for lines that only have 1 segment\n            if (coords.length === 2) {\n                finalCoords.push(segment[0]);\n                finalCoords.push(segment[1]);\n            }\n        }\n    });\n    return lineString(finalCoords, line.properties);\n}\n\n/**\n * Process Segment\n * Inspiration taken from http://stackoverflow.com/questions/2825412/draw-a-parallel-line\n *\n * @private\n * @param {Array<number>} point1 Point coordinates\n * @param {Array<number>} point2 Point coordinates\n * @param {number} offset Offset\n * @returns {Array<Array<number>>} offset points\n */\nfunction processSegment(point1, point2, offset) {\n    var L = Math.sqrt((point1[0] - point2[0]) * (point1[0] - point2[0]) + (point1[1] - point2[1]) * (point1[1] - point2[1]));\n\n    var out1x = point1[0] + offset * (point2[1] - point1[1]) / L;\n    var out2x = point2[0] + offset * (point2[1] - point1[1]) / L;\n    var out1y = point1[1] + offset * (point1[0] - point2[0]) / L;\n    var out2y = point2[1] + offset * (point1[0] - point2[0]) / L;\n    return [[out1x, out1y], [out2x, out2y]];\n}\n\nexport default lineOffset;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar helpers_1 = require(\"@turf/helpers\");\n/**\n * Takes a bbox and returns an equivalent {@link Polygon|polygon}.\n *\n * @name bboxPolygon\n * @param {BBox} bbox extent in [minX, minY, maxX, maxY] order\n * @param {Object} [options={}] Optional parameters\n * @param {Properties} [options.properties={}] Translate properties to Polygon\n * @param {string|number} [options.id={}] Translate Id to Polygon\n * @returns {Feature<Polygon>} a Polygon representation of the bounding box\n * @example\n * var bbox = [0, 0, 10, 10];\n *\n * var poly = turf.bboxPolygon(bbox);\n *\n * //addToMap\n * var addToMap = [poly]\n */\nfunction bboxPolygon(bbox, options) {\n    if (options === void 0) { options = {}; }\n    // Convert BBox positions to Numbers\n    // No performance loss for including Number()\n    // https://github.com/Turfjs/turf/issues/1119\n    var west = Number(bbox[0]);\n    var south = Number(bbox[1]);\n    var east = Number(bbox[2]);\n    var north = Number(bbox[3]);\n    if (bbox.length === 6) {\n        throw new Error(\"@turf/bbox-polygon does not support BBox with 6 positions\");\n    }\n    var lowLeft = [west, south];\n    var topLeft = [west, north];\n    var topRight = [east, north];\n    var lowRight = [east, south];\n    return helpers_1.polygon([[\n            lowLeft,\n            lowRight,\n            topRight,\n            topLeft,\n            lowLeft,\n        ]], options.properties, { bbox: bbox, id: options.id });\n}\nexports.default = bboxPolygon;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar invariant_1 = require(\"@turf/invariant\");\n// http://en.wikipedia.org/wiki/Even%E2%80%93odd_rule\n// modified from: https://github.com/substack/point-in-polygon/blob/master/index.js\n// which was modified from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n/**\n * Takes a {@link Point} and a {@link Polygon} or {@link MultiPolygon} and determines if the point\n * resides inside the polygon. The polygon can be convex or concave. The function accounts for holes.\n *\n * @name booleanPointInPolygon\n * @param {Coord} point input point\n * @param {Feature<Polygon|MultiPolygon>} polygon input polygon or multipolygon\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.ignoreBoundary=false] True if polygon boundary should be ignored when determining if\n * the point is inside the polygon otherwise false.\n * @returns {boolean} `true` if the Point is inside the Polygon; `false` if the Point is not inside the Polygon\n * @example\n * var pt = turf.point([-77, 44]);\n * var poly = turf.polygon([[\n *   [-81, 41],\n *   [-81, 47],\n *   [-72, 47],\n *   [-72, 41],\n *   [-81, 41]\n * ]]);\n *\n * turf.booleanPointInPolygon(pt, poly);\n * //= true\n */\nfunction booleanPointInPolygon(point, polygon, options) {\n    if (options === void 0) { options = {}; }\n    // validation\n    if (!point) {\n        throw new Error(\"point is required\");\n    }\n    if (!polygon) {\n        throw new Error(\"polygon is required\");\n    }\n    var pt = invariant_1.getCoord(point);\n    var geom = invariant_1.getGeom(polygon);\n    var type = geom.type;\n    var bbox = polygon.bbox;\n    var polys = geom.coordinates;\n    // Quick elimination if point is not inside bbox\n    if (bbox && inBBox(pt, bbox) === false) {\n        return false;\n    }\n    // normalize to multipolygon\n    if (type === \"Polygon\") {\n        polys = [polys];\n    }\n    var insidePoly = false;\n    for (var i = 0; i < polys.length && !insidePoly; i++) {\n        // check if it is in the outer ring first\n        if (inRing(pt, polys[i][0], options.ignoreBoundary)) {\n            var inHole = false;\n            var k = 1;\n            // check for the point in any of the holes\n            while (k < polys[i].length && !inHole) {\n                if (inRing(pt, polys[i][k], !options.ignoreBoundary)) {\n                    inHole = true;\n                }\n                k++;\n            }\n            if (!inHole) {\n                insidePoly = true;\n            }\n        }\n    }\n    return insidePoly;\n}\nexports.default = booleanPointInPolygon;\n/**\n * inRing\n *\n * @private\n * @param {Array<number>} pt [x,y]\n * @param {Array<Array<number>>} ring [[x,y], [x,y],..]\n * @param {boolean} ignoreBoundary ignoreBoundary\n * @returns {boolean} inRing\n */\nfunction inRing(pt, ring, ignoreBoundary) {\n    var isInside = false;\n    if (ring[0][0] === ring[ring.length - 1][0] && ring[0][1] === ring[ring.length - 1][1]) {\n        ring = ring.slice(0, ring.length - 1);\n    }\n    for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {\n        var xi = ring[i][0];\n        var yi = ring[i][1];\n        var xj = ring[j][0];\n        var yj = ring[j][1];\n        var onBoundary = (pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0) &&\n            ((xi - pt[0]) * (xj - pt[0]) <= 0) && ((yi - pt[1]) * (yj - pt[1]) <= 0);\n        if (onBoundary) {\n            return !ignoreBoundary;\n        }\n        var intersect = ((yi > pt[1]) !== (yj > pt[1])) &&\n            (pt[0] < (xj - xi) * (pt[1] - yi) / (yj - yi) + xi);\n        if (intersect) {\n            isInside = !isInside;\n        }\n    }\n    return isInside;\n}\n/**\n * inBBox\n *\n * @private\n * @param {Position} pt point [x,y]\n * @param {BBox} bbox BBox [west, south, east, north]\n * @returns {boolean} true/false if point is inside BBox\n */\nfunction inBBox(pt, bbox) {\n    return bbox[0] <= pt[0] &&\n        bbox[1] <= pt[1] &&\n        bbox[2] >= pt[0] &&\n        bbox[3] >= pt[1];\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar invariant_1 = require(\"@turf/invariant\");\n/**\n * Returns true if a point is on a line. Accepts a optional parameter to ignore the\n * start and end vertices of the linestring.\n *\n * @name booleanPointOnLine\n * @param {Coord} pt GeoJSON Point\n * @param {Feature<LineString>} line GeoJSON LineString\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.ignoreEndVertices=false] whether to ignore the start and end vertices.\n * @returns {boolean} true/false\n * @example\n * var pt = turf.point([0, 0]);\n * var line = turf.lineString([[-1, -1],[1, 1],[1.5, 2.2]]);\n * var isPointOnLine = turf.booleanPointOnLine(pt, line);\n * //=true\n */\nfunction booleanPointOnLine(pt, line, options) {\n    if (options === void 0) { options = {}; }\n    // Normalize inputs\n    var ptCoords = invariant_1.getCoord(pt);\n    var lineCoords = invariant_1.getCoords(line);\n    // Main\n    for (var i = 0; i < lineCoords.length - 1; i++) {\n        var ignoreBoundary = false;\n        if (options.ignoreEndVertices) {\n            if (i === 0) {\n                ignoreBoundary = \"start\";\n            }\n            if (i === lineCoords.length - 2) {\n                ignoreBoundary = \"end\";\n            }\n            if (i === 0 && i + 1 === lineCoords.length - 1) {\n                ignoreBoundary = \"both\";\n            }\n        }\n        if (isPointOnLineSegment(lineCoords[i], lineCoords[i + 1], ptCoords, ignoreBoundary)) {\n            return true;\n        }\n    }\n    return false;\n}\n// See http://stackoverflow.com/a/4833823/1979085\n/**\n * @private\n * @param {Position} lineSegmentStart coord pair of start of line\n * @param {Position} lineSegmentEnd coord pair of end of line\n * @param {Position} pt coord pair of point to check\n * @param {boolean|string} excludeBoundary whether the point is allowed to fall on the line ends.\n * If true which end to ignore.\n * @returns {boolean} true/false\n */\nfunction isPointOnLineSegment(lineSegmentStart, lineSegmentEnd, pt, excludeBoundary) {\n    var x = pt[0];\n    var y = pt[1];\n    var x1 = lineSegmentStart[0];\n    var y1 = lineSegmentStart[1];\n    var x2 = lineSegmentEnd[0];\n    var y2 = lineSegmentEnd[1];\n    var dxc = pt[0] - x1;\n    var dyc = pt[1] - y1;\n    var dxl = x2 - x1;\n    var dyl = y2 - y1;\n    var cross = dxc * dyl - dyc * dxl;\n    if (cross !== 0) {\n        return false;\n    }\n    if (!excludeBoundary) {\n        if (Math.abs(dxl) >= Math.abs(dyl)) {\n            return dxl > 0 ? x1 <= x && x <= x2 : x2 <= x && x <= x1;\n        }\n        return dyl > 0 ? y1 <= y && y <= y2 : y2 <= y && y <= y1;\n    }\n    else if (excludeBoundary === \"start\") {\n        if (Math.abs(dxl) >= Math.abs(dyl)) {\n            return dxl > 0 ? x1 < x && x <= x2 : x2 <= x && x < x1;\n        }\n        return dyl > 0 ? y1 < y && y <= y2 : y2 <= y && y < y1;\n    }\n    else if (excludeBoundary === \"end\") {\n        if (Math.abs(dxl) >= Math.abs(dyl)) {\n            return dxl > 0 ? x1 <= x && x < x2 : x2 < x && x <= x1;\n        }\n        return dyl > 0 ? y1 <= y && y < y2 : y2 < y && y <= y1;\n    }\n    else if (excludeBoundary === \"both\") {\n        if (Math.abs(dxl) >= Math.abs(dyl)) {\n            return dxl > 0 ? x1 < x && x < x2 : x2 < x && x < x1;\n        }\n        return dyl > 0 ? y1 < y && y < y2 : y2 < y && y < y1;\n    }\n    return false;\n}\nexports.default = booleanPointOnLine;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar bbox_1 = __importDefault(require(\"@turf/bbox\"));\nvar boolean_point_in_polygon_1 = __importDefault(require(\"@turf/boolean-point-in-polygon\"));\nvar boolean_point_on_line_1 = __importDefault(require(\"@turf/boolean-point-on-line\"));\nvar invariant_1 = require(\"@turf/invariant\");\n/**\n * Boolean-contains returns True if the second geometry is completely contained by the first geometry.\n * The interiors of both geometries must intersect and, the interior and boundary of the secondary (geometry b)\n * must not intersect the exterior of the primary (geometry a).\n * Boolean-contains returns the exact opposite result of the `@turf/boolean-within`.\n *\n * @name booleanContains\n * @param {Geometry|Feature<any>} feature1 GeoJSON Feature or Geometry\n * @param {Geometry|Feature<any>} feature2 GeoJSON Feature or Geometry\n * @returns {boolean} true/false\n * @example\n * var line = turf.lineString([[1, 1], [1, 2], [1, 3], [1, 4]]);\n * var point = turf.point([1, 2]);\n *\n * turf.booleanContains(line, point);\n * //=true\n */\nfunction booleanContains(feature1, feature2) {\n    var geom1 = invariant_1.getGeom(feature1);\n    var geom2 = invariant_1.getGeom(feature2);\n    var type1 = invariant_1.getType(feature1);\n    var type2 = invariant_1.getType(feature2);\n    var coords1 = invariant_1.getCoords(feature1);\n    var coords2 = invariant_1.getCoords(feature2);\n    switch (type1) {\n        case \"Point\":\n            switch (type2) {\n                case \"Point\":\n                    return compareCoords(coords1, coords2);\n                default:\n                    throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n            }\n        case \"MultiPoint\":\n            switch (type2) {\n                case \"Point\":\n                    return isPointInMultiPoint(geom1, geom2);\n                case \"MultiPoint\":\n                    return isMultiPointInMultiPoint(geom1, geom2);\n                default:\n                    throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n            }\n        case \"LineString\":\n            switch (type2) {\n                case \"Point\":\n                    return boolean_point_on_line_1.default(geom2, geom1, { ignoreEndVertices: true });\n                case \"LineString\":\n                    return isLineOnLine(geom1, geom2);\n                case \"MultiPoint\":\n                    return isMultiPointOnLine(geom1, geom2);\n                default:\n                    throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n            }\n        case \"Polygon\":\n            switch (type2) {\n                case \"Point\":\n                    return boolean_point_in_polygon_1.default(geom2, geom1, { ignoreBoundary: true });\n                case \"LineString\":\n                    return isLineInPoly(geom1, geom2);\n                case \"Polygon\":\n                    return isPolyInPoly(geom1, geom2);\n                case \"MultiPoint\":\n                    return isMultiPointInPoly(geom1, geom2);\n                default:\n                    throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n            }\n        default:\n            throw new Error(\"feature1 \" + type1 + \" geometry not supported\");\n    }\n}\nexports.default = booleanContains;\nfunction isPointInMultiPoint(multiPoint, pt) {\n    var i;\n    var output = false;\n    for (i = 0; i < multiPoint.coordinates.length; i++) {\n        if (compareCoords(multiPoint.coordinates[i], pt.coordinates)) {\n            output = true;\n            break;\n        }\n    }\n    return output;\n}\nexports.isPointInMultiPoint = isPointInMultiPoint;\nfunction isMultiPointInMultiPoint(multiPoint1, multiPoint2) {\n    for (var _i = 0, _a = multiPoint2.coordinates; _i < _a.length; _i++) {\n        var coord2 = _a[_i];\n        var matchFound = false;\n        for (var _b = 0, _c = multiPoint1.coordinates; _b < _c.length; _b++) {\n            var coord1 = _c[_b];\n            if (compareCoords(coord2, coord1)) {\n                matchFound = true;\n                break;\n            }\n        }\n        if (!matchFound) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.isMultiPointInMultiPoint = isMultiPointInMultiPoint;\nfunction isMultiPointOnLine(lineString, multiPoint) {\n    var haveFoundInteriorPoint = false;\n    for (var _i = 0, _a = multiPoint.coordinates; _i < _a.length; _i++) {\n        var coord = _a[_i];\n        if (boolean_point_on_line_1.default(coord, lineString, { ignoreEndVertices: true })) {\n            haveFoundInteriorPoint = true;\n        }\n        if (!boolean_point_on_line_1.default(coord, lineString)) {\n            return false;\n        }\n    }\n    if (haveFoundInteriorPoint) {\n        return true;\n    }\n    return false;\n}\nexports.isMultiPointOnLine = isMultiPointOnLine;\nfunction isMultiPointInPoly(polygon, multiPoint) {\n    for (var _i = 0, _a = multiPoint.coordinates; _i < _a.length; _i++) {\n        var coord = _a[_i];\n        if (!boolean_point_in_polygon_1.default(coord, polygon, { ignoreBoundary: true })) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.isMultiPointInPoly = isMultiPointInPoly;\nfunction isLineOnLine(lineString1, lineString2) {\n    var haveFoundInteriorPoint = false;\n    for (var _i = 0, _a = lineString2.coordinates; _i < _a.length; _i++) {\n        var coords = _a[_i];\n        if (boolean_point_on_line_1.default({ type: \"Point\", coordinates: coords }, lineString1, { ignoreEndVertices: true })) {\n            haveFoundInteriorPoint = true;\n        }\n        if (!boolean_point_on_line_1.default({ type: \"Point\", coordinates: coords }, lineString1, { ignoreEndVertices: false })) {\n            return false;\n        }\n    }\n    return haveFoundInteriorPoint;\n}\nexports.isLineOnLine = isLineOnLine;\nfunction isLineInPoly(polygon, linestring) {\n    var output = false;\n    var i = 0;\n    var polyBbox = bbox_1.default(polygon);\n    var lineBbox = bbox_1.default(linestring);\n    if (!doBBoxOverlap(polyBbox, lineBbox)) {\n        return false;\n    }\n    for (i; i < linestring.coordinates.length - 1; i++) {\n        var midPoint = getMidpoint(linestring.coordinates[i], linestring.coordinates[i + 1]);\n        if (boolean_point_in_polygon_1.default({ type: \"Point\", coordinates: midPoint }, polygon, { ignoreBoundary: true })) {\n            output = true;\n            break;\n        }\n    }\n    return output;\n}\nexports.isLineInPoly = isLineInPoly;\n/**\n * Is Polygon2 in Polygon1\n * Only takes into account outer rings\n *\n * @private\n * @param {Geometry|Feature<Polygon>} feature1 Polygon1\n * @param {Geometry|Feature<Polygon>} feature2 Polygon2\n * @returns {boolean} true/false\n */\nfunction isPolyInPoly(feature1, feature2) {\n    // Handle Nulls\n    if (feature1.type === \"Feature\" && feature1.geometry === null) {\n        return false;\n    }\n    if (feature2.type === \"Feature\" && feature2.geometry === null) {\n        return false;\n    }\n    var poly1Bbox = bbox_1.default(feature1);\n    var poly2Bbox = bbox_1.default(feature2);\n    if (!doBBoxOverlap(poly1Bbox, poly2Bbox)) {\n        return false;\n    }\n    var coords = invariant_1.getGeom(feature2).coordinates;\n    for (var _i = 0, coords_1 = coords; _i < coords_1.length; _i++) {\n        var ring = coords_1[_i];\n        for (var _a = 0, ring_1 = ring; _a < ring_1.length; _a++) {\n            var coord = ring_1[_a];\n            if (!boolean_point_in_polygon_1.default(coord, feature1)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\nexports.isPolyInPoly = isPolyInPoly;\nfunction doBBoxOverlap(bbox1, bbox2) {\n    if (bbox1[0] > bbox2[0]) {\n        return false;\n    }\n    if (bbox1[2] < bbox2[2]) {\n        return false;\n    }\n    if (bbox1[1] > bbox2[1]) {\n        return false;\n    }\n    if (bbox1[3] < bbox2[3]) {\n        return false;\n    }\n    return true;\n}\nexports.doBBoxOverlap = doBBoxOverlap;\n/**\n * compareCoords\n *\n * @private\n * @param {Position} pair1 point [x,y]\n * @param {Position} pair2 point [x,y]\n * @returns {boolean} true/false if coord pairs match\n */\nfunction compareCoords(pair1, pair2) {\n    return pair1[0] === pair2[0] && pair1[1] === pair2[1];\n}\nexports.compareCoords = compareCoords;\nfunction getMidpoint(pair1, pair2) {\n    return [(pair1[0] + pair2[0]) / 2, (pair1[1] + pair2[1]) / 2];\n}\nexports.getMidpoint = getMidpoint;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar helpers_1 = require(\"@turf/helpers\");\nvar invariant_1 = require(\"@turf/invariant\");\n// http://en.wikipedia.org/wiki/Haversine_formula\n// http://www.movable-type.co.uk/scripts/latlong.html\n/**\n * Takes two {@link Point|points} and finds the geographic bearing between them,\n * i.e. the angle measured in degrees from the north line (0 degrees)\n *\n * @name bearing\n * @param {Coord} start starting Point\n * @param {Coord} end ending Point\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.final=false] calculates the final bearing if true\n * @returns {number} bearing in decimal degrees, between -180 and 180 degrees (positive clockwise)\n * @example\n * var point1 = turf.point([-75.343, 39.984]);\n * var point2 = turf.point([-75.534, 39.123]);\n *\n * var bearing = turf.bearing(point1, point2);\n *\n * //addToMap\n * var addToMap = [point1, point2]\n * point1.properties['marker-color'] = '#f00'\n * point2.properties['marker-color'] = '#0f0'\n * point1.properties.bearing = bearing\n */\nfunction bearing(start, end, options) {\n    if (options === void 0) { options = {}; }\n    // Reverse calculation\n    if (options.final === true) {\n        return calculateFinalBearing(start, end);\n    }\n    var coordinates1 = invariant_1.getCoord(start);\n    var coordinates2 = invariant_1.getCoord(end);\n    var lon1 = helpers_1.degreesToRadians(coordinates1[0]);\n    var lon2 = helpers_1.degreesToRadians(coordinates2[0]);\n    var lat1 = helpers_1.degreesToRadians(coordinates1[1]);\n    var lat2 = helpers_1.degreesToRadians(coordinates2[1]);\n    var a = Math.sin(lon2 - lon1) * Math.cos(lat2);\n    var b = Math.cos(lat1) * Math.sin(lat2) -\n        Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);\n    return helpers_1.radiansToDegrees(Math.atan2(a, b));\n}\n/**\n * Calculates Final Bearing\n *\n * @private\n * @param {Coord} start starting Point\n * @param {Coord} end ending Point\n * @returns {number} bearing\n */\nfunction calculateFinalBearing(start, end) {\n    // Swap start & end\n    var bear = bearing(end, start);\n    bear = (bear + 180) % 360;\n    return bear;\n}\nexports.default = bearing;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// http://en.wikipedia.org/wiki/Haversine_formula\n// http://www.movable-type.co.uk/scripts/latlong.html\nvar helpers_1 = require(\"@turf/helpers\");\nvar invariant_1 = require(\"@turf/invariant\");\n/**\n * Takes a {@link Point} and calculates the location of a destination point given a distance in\n * degrees, radians, miles, or kilometers; and bearing in degrees.\n * This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.\n *\n * @name destination\n * @param {Coord} origin starting point\n * @param {number} distance distance from the origin point\n * @param {number} bearing ranging from -180 to 180\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] miles, kilometers, degrees, or radians\n * @param {Object} [options.properties={}] Translate properties to Point\n * @returns {Feature<Point>} destination point\n * @example\n * var point = turf.point([-75.343, 39.984]);\n * var distance = 50;\n * var bearing = 90;\n * var options = {units: 'miles'};\n *\n * var destination = turf.destination(point, distance, bearing, options);\n *\n * //addToMap\n * var addToMap = [point, destination]\n * destination.properties['marker-color'] = '#f00';\n * point.properties['marker-color'] = '#0f0';\n */\nfunction destination(origin, distance, bearing, options) {\n    if (options === void 0) { options = {}; }\n    // Handle input\n    var coordinates1 = invariant_1.getCoord(origin);\n    var longitude1 = helpers_1.degreesToRadians(coordinates1[0]);\n    var latitude1 = helpers_1.degreesToRadians(coordinates1[1]);\n    var bearingRad = helpers_1.degreesToRadians(bearing);\n    var radians = helpers_1.lengthToRadians(distance, options.units);\n    // Main\n    var latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians) +\n        Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearingRad));\n    var longitude2 = longitude1 + Math.atan2(Math.sin(bearingRad) * Math.sin(radians) * Math.cos(latitude1), Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2));\n    var lng = helpers_1.radiansToDegrees(longitude2);\n    var lat = helpers_1.radiansToDegrees(latitude2);\n    return helpers_1.point([lng, lat], options.properties);\n}\nexports.default = destination;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar invariant_1 = require(\"@turf/invariant\");\nvar helpers_1 = require(\"@turf/helpers\");\n//http://en.wikipedia.org/wiki/Haversine_formula\n//http://www.movable-type.co.uk/scripts/latlong.html\n/**\n * Calculates the distance between two {@link Point|points} in degrees, radians, miles, or kilometers.\n * This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.\n *\n * @name distance\n * @param {Coord} from origin point\n * @param {Coord} to destination point\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @returns {number} distance between the two points\n * @example\n * var from = turf.point([-75.343, 39.984]);\n * var to = turf.point([-75.534, 39.123]);\n * var options = {units: 'miles'};\n *\n * var distance = turf.distance(from, to, options);\n *\n * //addToMap\n * var addToMap = [from, to];\n * from.properties.distance = distance;\n * to.properties.distance = distance;\n */\nfunction distance(from, to, options) {\n    if (options === void 0) { options = {}; }\n    var coordinates1 = invariant_1.getCoord(from);\n    var coordinates2 = invariant_1.getCoord(to);\n    var dLat = helpers_1.degreesToRadians((coordinates2[1] - coordinates1[1]));\n    var dLon = helpers_1.degreesToRadians((coordinates2[0] - coordinates1[0]));\n    var lat1 = helpers_1.degreesToRadians(coordinates1[1]);\n    var lat2 = helpers_1.degreesToRadians(coordinates2[1]);\n    var a = Math.pow(Math.sin(dLat / 2), 2) +\n        Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);\n    return helpers_1.radiansToLength(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), options.units);\n}\nexports.default = distance;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar bbox_1 = require(\"@turf/bbox\");\nvar helpers_1 = require(\"@turf/helpers\");\n/**\n * Takes a {@link Feature} or {@link FeatureCollection} and returns the absolute center point of all features.\n *\n * @name center\n * @param {GeoJSON} geojson GeoJSON to be centered\n * @param {Object} [options={}] Optional parameters\n * @param {Object} [options.properties={}] Translate GeoJSON Properties to Point\n * @param {Object} [options.bbox={}] Translate GeoJSON BBox to Point\n * @param {Object} [options.id={}] Translate GeoJSON Id to Point\n * @returns {Feature<Point>} a Point feature at the absolute center point of all input features\n * @example\n * var features = turf.points([\n *   [-97.522259, 35.4691],\n *   [-97.502754, 35.463455],\n *   [-97.508269, 35.463245]\n * ]);\n *\n * var center = turf.center(features);\n *\n * //addToMap\n * var addToMap = [features, center]\n * center.properties['marker-size'] = 'large';\n * center.properties['marker-color'] = '#000';\n */\nfunction center(geojson, options) {\n    if (options === void 0) { options = {}; }\n    var ext = bbox_1.default(geojson);\n    var x = (ext[0] + ext[2]) / 2;\n    var y = (ext[1] + ext[3]) / 2;\n    return helpers_1.point([x, y], options.properties, options);\n}\nexports.default = center;\n","import lineIntersect from '@turf/line-intersect';\r\nimport lineOffset from '@turf/line-offset';\r\nimport { lineString, featureCollection, point } from '@turf/helpers';\r\nimport bboxPolygon from '@turf/bbox-polygon';\r\nimport booleanContains from '@turf/boolean-contains';\r\nimport bearing from '@turf/bearing';\r\nimport destination from '@turf/destination';\r\nimport distance from '@turf/distance';\r\nimport center from '@turf/center';\r\n\r\nexport default class GuidingLines {\r\n\r\n    // Interval in meters\r\n    // Bbox : containing bbox of the grid\r\n    // Reference line, strait [pointA, pointB] or curve [pointA, pointB, pointC, pointD]\r\n    constructor(interval = 5, referenceLine, bbox) {\r\n        this.interval = interval;\r\n        this.bbox = bbox;\r\n        this.referenceLine = referenceLine;\r\n        this.lines = [];\r\n        this.computeDerivedParams();\r\n    }\r\n\r\n    computeDerivedParams() {\r\n        this.bboxGeojson = bboxPolygon(this.bbox);\r\n        this.referenceLineGeojson = lineString(this.referenceLine);\r\n        // Bearing of reference line first and last point\r\n        this.referenceLineBearing = bearing(point(this.referenceLine[0]), point(this.referenceLine[this.referenceLine.length - 1]));\r\n        this.referenceLineBearingInverse = bearing(point(this.referenceLine[this.referenceLine.length - 1]), point(this.referenceLine[0]));\r\n        //console.log(`Reference line bearing: ${this.referenceLineBearing}`);\r\n        //console.log(`Reference line bearing inverse: ${this.referenceLineBearingInverse}`);\r\n        // Bbox diagonal length in meters\r\n        this.bboxDiagonalLength = distance(point([this.bbox[0], this.bbox[1]]), point([this.bbox[2], this.bbox[3]]), {units: 'kilometers'}) * 1000;\r\n        //console.log(`bboxDiagonalLength in meters: ${this.bboxDiagonalLength}m`);\r\n    }\r\n\r\n    isBiggerThan(newBbox) {\r\n        if(booleanContains(this.bboxGeojson, bboxPolygon(newBbox))) {\r\n            return true;\r\n        } else {\r\n            // Need to be resized\r\n            return false;\r\n        }\r\n    }\r\n\r\n    isLineInBbox(line) {\r\n        // Check if Inside, and if it is not, if intersects\r\n        if(booleanContains(this.bboxGeojson, line)) {\r\n            return true;\r\n        } else {\r\n            if(lineIntersect(this.bboxGeojson, line).features.length > 0) {\r\n                return true;\r\n            } else {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Get line passing threw position and perpendicular to bearing\r\n    computePerpendicularLine(position, bearing, halfLength) {\r\n        let pointPosition = point(position);\r\n        let pointA = destination(pointPosition, halfLength, bearing + 90, { units: \"meters\" });\r\n        let pointB = destination(pointPosition, halfLength, bearing - 90, { units: \"meters\" });\r\n        return lineString([pointA.geometry.coordinates, pointB.geometry.coordinates]);\r\n    }\r\n\r\n    expandLine(line) {\r\n        // if it's not already bigger than bbox (intersecting in 2 points)\r\n        if(lineIntersect(line, this.bboxGeojson).features.length < 2) {\r\n            let currentLineCoordinates = line.geometry.coordinates;\r\n            let newLineCoordinates = [\r\n                destination(currentLineCoordinates[0], this.bboxDiagonalLength, this.referenceLineBearingInverse, { units: \"meters\" }).geometry.coordinates,\r\n                ...currentLineCoordinates,\r\n                destination(currentLineCoordinates[currentLineCoordinates.length - 1], this.bboxDiagonalLength,  this.referenceLineBearing, { units: \"meters\" }).geometry.coordinates,\r\n            ]\r\n            return lineString(newLineCoordinates);\r\n        } else {\r\n            return line;\r\n        }  \r\n        \r\n    }\r\n\r\n    generate() {\r\n        // If reference line isn't inside bbox, return error\r\n        if(!this.isLineInBbox(this.referenceLineGeojson)) {\r\n            console.log(`Error: reference line isn't inside bbox container`)\r\n            return;\r\n        }\r\n\r\n        // Reset lines\r\n        this.lines = [];\r\n\r\n        // Expand reference line to meet the bbox size\r\n        // TODO, this cause pb if not a straith line\r\n        // TODO, see if we want to cut\r\n        let referenceLineExpanded =  this.expandLine(this.referenceLineGeojson);\r\n        \r\n        // Create all parallels lines and store them\r\n        let linesRight = []\r\n        let linesLeft = []\r\n        let previousLine = referenceLineExpanded;\r\n        let lineOffsetted = lineOffset(previousLine, this.interval, { units: \"meters\" });\r\n\r\n        // while inside BBOX \r\n        while (this.isLineInBbox(lineOffsetted)) {\r\n            // Add to line list\r\n            linesRight.push(lineOffsetted);\r\n            // Create new parralel line\r\n            previousLine = lineOffsetted;\r\n            lineOffsetted = lineOffset(previousLine, this.interval, { units: \"meters\" });\r\n            lineOffsetted = this.expandLine(lineOffsetted);\r\n        }\r\n\r\n        //console.log(`Created ${linesRight.length} to the right`);\r\n\r\n        lineOffsetted = lineOffset(referenceLineExpanded, -this.interval, { units: \"meters\" });\r\n\r\n        // while inside BBOX \r\n        while (this.isLineInBbox(lineOffsetted)) {\r\n            // Add to line list\r\n            linesLeft.push(lineOffsetted);\r\n            // create new parralel line\r\n            previousLine = lineOffsetted;\r\n            lineOffsetted = lineOffset(previousLine, -this.interval, { units: \"meters\" });\r\n            lineOffsetted = this.expandLine(lineOffsetted);\r\n        }\r\n\r\n        //console.log(`Created ${linesLeft.length} to the left`);\r\n\r\n        this.lines = this.lines.concat(linesLeft.reverse());\r\n        this.lines = this.lines.concat(referenceLineExpanded);\r\n        this.lines = this.lines.concat(linesRight);\r\n\r\n        // For each assign an index in the property field (this will be used when using getClosestLine for styling)\r\n        // lines.map((line, index) => {\r\n        //   line.property.id = index;\r\n        //})\r\n\r\n        return featureCollection(this.lines);\r\n    }\r\n\r\n    // IDEA: if not fast enough, could build also a memory of last position computation\r\n    // and restrict even more the number of lines to loop trough because we would know \r\n    // distance between last position and new position and could know how many lines could potentialy be in between\r\n    getClosestLine(position) {\r\n        // Draw perpendicular line to bearing of reference line\r\n        let perpendicularLine = this.computePerpendicularLine(position, this.referenceLineBearing, this.bboxDiagonalLength);\r\n\r\n        // As the list of guiding lines is ordered (parallel lines)\r\n        // We can perform a binary search to avoid looping through all the list\r\n        // We could implemnt this with a recursive function also\r\n        let found = false;\r\n        let boundA = 0;\r\n        let boundB = this.lines.length - 1;\r\n        let distanceToBoundA = this.bboxDiagonalLength;\r\n        let distanceToBoundB = this.bboxDiagonalLength;\r\n        let intersectionWithBoundA = null;\r\n        let intersectionWithBoundB = null;\r\n        let closestDistance = this.bboxDiagonalLength;\r\n        let closest = null;\r\n\r\n        while (!found) {\r\n            //console.log(`boundA: ${boundA}, boundB: ${boundB}`)\r\n            // Pick closest bound\r\n            intersectionWithBoundA = lineIntersect(perpendicularLine, this.lines[boundA]);\r\n            intersectionWithBoundB = lineIntersect(perpendicularLine, this.lines[boundB]);\r\n            if(intersectionWithBoundA.features.length > 0) {\r\n                //console.log(`NB Intersection with boundA: ${intersectionWithBoundA.features.length}`)\r\n                distanceToBoundA = distance(intersectionWithBoundA.features[0], point(position), {units: 'kilometers'}) * 1000;\r\n                //console.log(`Distance to boundA: ${distanceToBoundA} m`)\r\n            }\r\n            if(intersectionWithBoundB.features.length > 0) {\r\n                //console.log(`NB Intersection with boundB: ${intersectionWithBoundB.features.length}`)\r\n                distanceToBoundB = distance(intersectionWithBoundB.features[0], point(position), {units: 'kilometers'}) * 1000;\r\n                //console.log(`Distance to boundB: ${distanceToBoundB} m`)\r\n            }\r\n\r\n            // Set new bounds\r\n            if(distanceToBoundA > distanceToBoundB) {\r\n                // If 1 between A and B , floor will keep giving same number\r\n                if(boundB - boundA === 1) {\r\n                    boundA = boundB;\r\n                } else {\r\n                    boundA = boundA + Math.floor((boundB - boundA) / 2);\r\n                }\r\n                //console.log(`closest to boundB, move boundA to ${boundA}`)\r\n                if(boundA === boundB){\r\n                    closestDistance = distanceToBoundB;\r\n                    found = true;\r\n                }\r\n            } else {\r\n                // If 1 between A and B , floor will keep giving same number\r\n                if(boundB - boundA === 1) {\r\n                    boundB = boundA;\r\n                } else {\r\n                    boundB = boundB - Math.floor((boundB - boundA) / 2);\r\n                }\r\n                //console.log(`closest to boundA, move boundB to ${boundB}`)\r\n                if(boundA === boundB){\r\n                    closestDistance = distanceToBoundA;\r\n                    found = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        closest = {\r\n            index: boundA,\r\n            distance: closestDistance,\r\n            line: this.lines[boundA],\r\n            perpendicularLine: perpendicularLine\r\n        }\r\n\r\n        return closest;\r\n    }\r\n\r\n    // Get guiding lines in geojson to display on a map\r\n    getGeojson() {\r\n        return featureCollection(this.lines);\r\n    }\r\n\r\n    // Change Guiding parameters\r\n    update(bbox, interval) {\r\n        this.bbox = bbox;\r\n        this.interval = interval;\r\n        this.generate();\r\n        // NB: when changing interval / bbox size, the index will change for the lines, so user needs to call getClosestLineAgain\r\n    }\r\n\r\n    updateBbox(newBbox) {\r\n        // NB: when changing interval / bbox size, the index will change for the lines, so user needs to call getClosestLineAgain\r\n        // Set closest line to center of bbox as new reference line\r\n        let bboxCenter = center(bboxPolygon(newBbox));\r\n        let newReferenceLine = this.getClosestLine(bboxCenter.geometry.coordinates);\r\n        if(!newReferenceLine) {\r\n            console.log(`Can't update bbox, you moved too far away from previous bbox location, need to have some overlap to be able to compute it`)\r\n            return false;\r\n        } else {\r\n            console.log('Update Bbox and recompute everything')\r\n            this.referenceLine = newReferenceLine.line.geometry.coordinates;\r\n            this.bbox = newBbox;\r\n            this.computeDerivedParams();\r\n            return true;\r\n        }\r\n    }\r\n}\r\n\r\n","import GuidingLines from './guidinglines';\r\nimport bboxPolygon from '@turf/bbox-polygon';\r\n\r\n\r\nvar position = [-121.415061, 40.506229];\r\n\r\nvar map = new mapboxgl.Map({\r\n    container: \"map\",\r\n    style: {\r\n        \"version\": 8,\r\n        \"sources\": {\r\n            \"simple-tiles\": {\r\n                \"type\": \"raster\",\r\n                // point to our third-party tiles. Note that some examples\r\n                // show a \"url\" property. This only applies to tilesets with\r\n                // corresponding TileJSON (such as mapbox tiles). \r\n                \"tiles\": [\r\n                    \"http://a.tile.openstreetmap.org/{z}/{x}/{y}.png\",\r\n                    \"http://b.tile.openstreetmap.org/{z}/{x}/{y}.png\"\r\n                ],\r\n                \"tileSize\": 256\r\n            }\r\n        },\r\n        \"layers\": [{\r\n            \"id\": \"simple-tiles\",\r\n            \"type\": \"raster\",\r\n            \"source\": \"simple-tiles\",\r\n            \"minzoom\": 0,\r\n            \"maxzoom\": 22\r\n        }]\r\n    },\r\n    center: position,\r\n    zoom: 17\r\n});\r\n\r\nmap.on(\"load\", function () {\r\n\r\n    // Get bbox from bounds\r\n    var bbox = map.getBounds().toArray().flat()\r\n\r\n    var bboxGeojson = bboxPolygon(bbox);\r\n\r\n    var referenceLine = [[-121.418961, 40.506229], [-121.412, 40.51]];\r\n    var guidingLines = new GuidingLines(50, referenceLine, bbox);\r\n    var guidingLinesGeojson = guidingLines.generate();\r\n    var perpendicularLine = guidingLines.computePerpendicularLine(position, guidingLines.referenceLineBearing, guidingLines.bboxDiagonalLength);\r\n\r\n    var closestLine = guidingLines.getClosestLine(position);\r\n\r\n    map.addSource(\"helper\", {\r\n        \"type\": \"geojson\",\r\n        \"data\": {\r\n            \"type\": \"FeatureCollection\",\r\n            \"features\": [\r\n                bboxGeojson\r\n                , {\r\n                    \"type\": \"Feature\",\r\n                    \"geometry\": {\r\n                        \"type\": \"Point\",\r\n                        \"coordinates\": position\r\n                    }\r\n                },\r\n                //perpendicularLine,\r\n                closestLine.line\r\n            ]\r\n        }\r\n    });\r\n\r\n    //console.log(guidingLinesGeojson);\r\n\r\n    map.addSource(\"guiding-lines\", {\r\n        \"type\": \"geojson\",\r\n        \"data\": guidingLinesGeojson\r\n    })\r\n\r\n    map.addLayer({\r\n        \"id\": \"guidinglines\",\r\n        \"type\": \"line\",\r\n        \"source\": \"guiding-lines\",\r\n        \"paint\": {\r\n            \"line-color\": \"green\",\r\n            \"line-width\": 2\r\n        },\r\n        \"filter\": [\"==\", \"$type\", \"LineString\"],\r\n    });\r\n\r\n    map.addLayer({\r\n        \"id\": \"bbox-boundary\",\r\n        \"type\": \"fill\",\r\n        \"source\": \"helper\",\r\n        \"paint\": {\r\n            \"fill-color\": \"#888888\",\r\n            \"fill-opacity\": 0.1\r\n        }\r\n    });\r\n\r\n    map.addLayer({\r\n        \"id\": \"position\",\r\n        \"type\": \"circle\",\r\n        \"source\": \"helper\",\r\n        \"paint\": {\r\n            \"circle-radius\": 6,\r\n            \"circle-color\": \"#B42222\"\r\n        },\r\n        \"filter\": [\"==\", \"$type\", \"Point\"],\r\n    });\r\n\r\n    map.addLayer({\r\n        \"id\": \"perpendicularline\",\r\n        \"type\": \"line\",\r\n        \"source\": \"helper\",\r\n        \"paint\": {\r\n            \"line-color\": \"blue\",\r\n            \"line-width\": 2\r\n        },\r\n        \"filter\": [\"==\", \"$type\", \"LineString\"],\r\n    });\r\n\r\n    map.on('moveend', () => {\r\n        console.log('moveend');\r\n        var newBbox = map.getBounds().toArray().flat();\r\n        var needResizing = !guidingLines.isBiggerThan(newBbox);\r\n        // If bounds are bigger than the bbox, need to resize the guiding lines\r\n        if(needResizing) {\r\n            console.log('Update bbox')\r\n            var updated = guidingLines.updateBbox(newBbox);\r\n\r\n            if(updated) {\r\n                console.log('Generate guidinglines')\r\n                var guidingLinesGeojson = guidingLines.generate();\r\n                map.getSource('guiding-lines').setData(guidingLinesGeojson);\r\n            }\r\n        }\r\n\r\n        console.log('Compute closest line')\r\n        position = map.getCenter().toArray();\r\n        var closestLine = guidingLines.getClosestLine(position);\r\n        map.getSource('helper').setData({\r\n            \"type\": \"FeatureCollection\",\r\n            \"features\": [\r\n                bboxGeojson\r\n                , {\r\n                    \"type\": \"Feature\",\r\n                    \"geometry\": {\r\n                        \"type\": \"Point\",\r\n                        \"coordinates\": position\r\n                    }\r\n                },\r\n                //closestLine.perpendicularLine,\r\n                closestLine.line\r\n            ]\r\n        });\r\n    })\r\n\r\n    // TODO Need to use https://docs.mapbox.com/mapbox-gl-js/style-spec/#expressions\r\n    // To style current line differently\r\n\r\n    window.guidingLines = guidingLines;\r\n    window.map = map;\r\n});\r\n\r\n\r\n","var OVERLAY_ID = '__parcel__error__overlay__';\n\nvar OldModule = module.bundle.Module;\n\nfunction Module(moduleName) {\n  OldModule.call(this, moduleName);\n  this.hot = {\n    data: module.bundle.hotData,\n    _acceptCallbacks: [],\n    _disposeCallbacks: [],\n    accept: function (fn) {\n      this._acceptCallbacks.push(fn || function () {});\n    },\n    dispose: function (fn) {\n      this._disposeCallbacks.push(fn);\n    }\n  };\n\n  module.bundle.hotData = null;\n}\n\nmodule.bundle.Module = Module;\nvar checkedAssets, assetsToAccept;\n\nvar parent = module.bundle.parent;\nif ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {\n  var hostname = process.env.HMR_HOSTNAME || location.hostname;\n  var protocol = location.protocol === 'https:' ? 'wss' : 'ws';\n  var ws = new WebSocket(protocol + '://' + hostname + ':' + process.env.HMR_PORT + '/');\n  ws.onmessage = function(event) {\n    checkedAssets = {};\n    assetsToAccept = [];\n\n    var data = JSON.parse(event.data);\n\n    if (data.type === 'update') {\n      var handled = false;\n      data.assets.forEach(function(asset) {\n        if (!asset.isNew) {\n          var didAccept = hmrAcceptCheck(global.parcelRequire, asset.id);\n          if (didAccept) {\n            handled = true;\n          }\n        }\n      });\n\n      // Enable HMR for CSS by default.\n      handled = handled || data.assets.every(function(asset) {\n        return asset.type === 'css' && asset.generated.js;\n      });\n\n      if (handled) {\n        console.clear();\n\n        data.assets.forEach(function (asset) {\n          hmrApply(global.parcelRequire, asset);\n        });\n\n        assetsToAccept.forEach(function (v) {\n          hmrAcceptRun(v[0], v[1]);\n        });\n      } else {\n        window.location.reload();\n      }\n    }\n\n    if (data.type === 'reload') {\n      ws.close();\n      ws.onclose = function () {\n        location.reload();\n      }\n    }\n\n    if (data.type === 'error-resolved') {\n      console.log('[parcel] ✨ Error resolved');\n\n      removeErrorOverlay();\n    }\n\n    if (data.type === 'error') {\n      console.error('[parcel] 🚨  ' + data.error.message + '\\n' + data.error.stack);\n\n      removeErrorOverlay();\n\n      var overlay = createErrorOverlay(data);\n      document.body.appendChild(overlay);\n    }\n  };\n}\n\nfunction removeErrorOverlay() {\n  var overlay = document.getElementById(OVERLAY_ID);\n  if (overlay) {\n    overlay.remove();\n  }\n}\n\nfunction createErrorOverlay(data) {\n  var overlay = document.createElement('div');\n  overlay.id = OVERLAY_ID;\n\n  // html encode message and stack trace\n  var message = document.createElement('div');\n  var stackTrace = document.createElement('pre');\n  message.innerText = data.error.message;\n  stackTrace.innerText = data.error.stack;\n\n  overlay.innerHTML = (\n    '<div style=\"background: black; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; opacity: 0.85; font-family: Menlo, Consolas, monospace; z-index: 9999;\">' +\n      '<span style=\"background: red; padding: 2px 4px; border-radius: 2px;\">ERROR</span>' +\n      '<span style=\"top: 2px; margin-left: 5px; position: relative;\">🚨</span>' +\n      '<div style=\"font-size: 18px; font-weight: bold; margin-top: 20px;\">' + message.innerHTML + '</div>' +\n      '<pre>' + stackTrace.innerHTML + '</pre>' +\n    '</div>'\n  );\n\n  return overlay;\n\n}\n\nfunction getParents(bundle, id) {\n  var modules = bundle.modules;\n  if (!modules) {\n    return [];\n  }\n\n  var parents = [];\n  var k, d, dep;\n\n  for (k in modules) {\n    for (d in modules[k][1]) {\n      dep = modules[k][1][d];\n      if (dep === id || (Array.isArray(dep) && dep[dep.length - 1] === id)) {\n        parents.push(k);\n      }\n    }\n  }\n\n  if (bundle.parent) {\n    parents = parents.concat(getParents(bundle.parent, id));\n  }\n\n  return parents;\n}\n\nfunction hmrApply(bundle, asset) {\n  var modules = bundle.modules;\n  if (!modules) {\n    return;\n  }\n\n  if (modules[asset.id] || !bundle.parent) {\n    var fn = new Function('require', 'module', 'exports', asset.generated.js);\n    asset.isNew = !modules[asset.id];\n    modules[asset.id] = [fn, asset.deps];\n  } else if (bundle.parent) {\n    hmrApply(bundle.parent, asset);\n  }\n}\n\nfunction hmrAcceptCheck(bundle, id) {\n  var modules = bundle.modules;\n  if (!modules) {\n    return;\n  }\n\n  if (!modules[id] && bundle.parent) {\n    return hmrAcceptCheck(bundle.parent, id);\n  }\n\n  if (checkedAssets[id]) {\n    return;\n  }\n  checkedAssets[id] = true;\n\n  var cached = bundle.cache[id];\n\n  assetsToAccept.push([bundle, id]);\n\n  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {\n    return true;\n  }\n\n  return getParents(global.parcelRequire, id).some(function (id) {\n    return hmrAcceptCheck(global.parcelRequire, id)\n  });\n}\n\nfunction hmrAcceptRun(bundle, id) {\n  var cached = bundle.cache[id];\n  bundle.hotData = {};\n  if (cached) {\n    cached.hot.data = bundle.hotData;\n  }\n\n  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {\n    cached.hot._disposeCallbacks.forEach(function (cb) {\n      cb(bundle.hotData);\n    });\n  }\n\n  delete bundle.cache[id];\n  bundle(id);\n\n  cached = bundle.cache[id];\n  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {\n    cached.hot._acceptCallbacks.forEach(function (cb) {\n      cb();\n    });\n    return true;\n  }\n}\n"]}